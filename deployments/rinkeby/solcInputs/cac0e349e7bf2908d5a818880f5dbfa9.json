{
  "language": "Solidity",
  "sources": {
    "contracts/ActionVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./libs/SignatureVerifier.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IEscrow.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title AllianceBlock ActionVerifier contract\n * @dev Extends Initializable, OwnableUpgradeable\n * @notice Handles user's Actions and Rewards within the protocol\n */\ncontract ActionVerifier is Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using SignatureVerifier for SignatureVerifier.Action;\n\n    mapping(bytes32 => uint256) public rewardPerAction;\n    uint256 public rewardPerActionProvision;\n    uint256 public maxActionsPerProvision;\n\n    IEscrow public escrow;\n    IStaking public staking;\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    bytes32 public constant EIP712DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    struct EIP712Domain {\n        string name;\n        string version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    /**\n     * @dev Initializer of the ActionVerifier contract.\n     * @param rewardPerActionProvision_ The reward that an action provider accumulates for each action provision.\n     * @param maxActionsPerProvision_ The max actions that an account can take rewards for in one function call.\n     * @param escrow_ The address of the escrow.\n     */\n    function initialize(\n        uint256 rewardPerActionProvision_,\n        uint256 maxActionsPerProvision_,\n        address escrow_,\n        address staking_,\n        uint256 chainId\n    ) public initializer {\n        __Ownable_init();\n        escrow = IEscrow(escrow_);\n        staking = IStaking(staking_);\n        rewardPerActionProvision = rewardPerActionProvision_;\n        maxActionsPerProvision = maxActionsPerProvision_;\n\n        DOMAIN_SEPARATOR = hash(\n            EIP712Domain({\n                name: \"AllianceBlock Verifier\",\n                version: \"1.0\",\n                chainId: chainId,\n                verifyingContract: address(this)\n            })\n        );\n    }\n\n    function hash(EIP712Domain memory eip712Domain) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712DOMAIN_TYPEHASH,\n                    keccak256(bytes(eip712Domain.name)),\n                    keccak256(bytes(eip712Domain.version)),\n                    eip712Domain.chainId,\n                    eip712Domain.verifyingContract\n                )\n            );\n    }\n\n    /**\n     * @dev This function is used by the owner to update variables.\n     * @param rewardPerActionProvision_ The reward that an action provider accumulates for each action provision.\n     * @param maxActionsPerProvision_ The max actions that an account can take rewards for in one function call.\n     */\n    function updateVariables(uint256 rewardPerActionProvision_, uint256 maxActionsPerProvision_) external onlyOwner() {\n        rewardPerActionProvision = rewardPerActionProvision_;\n        maxActionsPerProvision = maxActionsPerProvision_;\n    }\n\n    /**\n     * @dev This function is used by the owner to add more actions.\n     * @param action The name of the action.\n     * @param reputationalAlbtReward The reputational albt reward for this action.\n     */\n    function importAction(string memory action, uint256 reputationalAlbtReward) external onlyOwner() {\n        rewardPerAction[keccak256(abi.encodePacked(action))] = reputationalAlbtReward;\n    }\n\n    /**\n     * @dev This function is used by the owner to update actions.\n     * @param action The name of the action.\n     * @param reputationalAlbtReward The reputational albt reward for this action.\n     */\n    function updateAction(string memory action, uint256 reputationalAlbtReward) external onlyOwner() {\n        require(rewardPerAction[keccak256(abi.encodePacked(action))] > 0, \"Action should already exist\");\n        rewardPerAction[keccak256(abi.encodePacked(action))] = reputationalAlbtReward;\n    }\n\n    /**\n     * @dev This function is used by users to provide rewards to all users for their actions.\n     * @param actions The actions provided.\n     * @param signatures The signatures representing the actions.\n     */\n    function provideRewardsForActions(SignatureVerifier.Action[] memory actions, bytes[] memory signatures) external {\n        require(staking.getEligibilityForActionProvision(msg.sender), \"Must be at least lvl2 staker\");\n        require(actions.length == signatures.length, \"Invalid length\");\n        require(actions.length <= maxActionsPerProvision, \"Too many actions\");\n\n        address[] memory accounts = new address[](actions.length.add(1));\n        uint256[] memory rewards = new uint256[](actions.length.add(1));\n\n        uint256 rewardForCaller;\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            if (\n                actions[i].isValidSignature(signatures[i], DOMAIN_SEPARATOR) &&\n                rewardPerAction[keccak256(abi.encodePacked(actions[i].actionName))] > 0\n            ) {\n                accounts[i] = actions[i].account;\n                rewards[i] = rewardPerAction[keccak256(abi.encodePacked(actions[i].actionName))];\n\n                rewardForCaller = rewardForCaller.add(rewardPerActionProvision);\n            } else {\n                accounts[i] = address(0);\n                rewards[i] = 0;\n            }\n        }\n\n        accounts[actions.length] = msg.sender;\n        rewards[actions.length] = rewardForCaller;\n\n        escrow.multiMintReputationalToken(accounts, rewards);\n    }\n\n    /**\n     * @notice Check Action\n     * @dev checks if given action has a reward\n     * @return exist boolean represents checks if action has a reward associated\n     */\n    function checkAction(string memory action) public view returns (bool exist) {\n        return rewardPerAction[keccak256(abi.encodePacked(action))] > 0;\n    }\n}\n"
    },
    "contracts/libs/SignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BytesReader.sol\";\n\n/**\n * @title Signature Verifier Library\n */\nlibrary SignatureVerifier {\n    using BytesReader for bytes;\n\n    struct Action {\n        string actionName;\n        string answer;\n        address account;\n        uint256 referralId;\n    }\n    bytes32 constant ACTION_TYPEHASH = 0x1f76bf6993440811cef7b51dc00dee9d4e8fa911023c7f2d088ce4e46ac2346f;\n\n    /**\n     * @notice Gets Actions struct hash\n     * @param action the Action to retrieve\n     * @return the keccak hash Action struct\n     */\n    function getActionStructHash(Action memory action) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    ACTION_TYPEHASH,\n                    keccak256(bytes(action.actionName)),\n                    keccak256(bytes(action.answer)),\n                    action.account,\n                    action.referralId\n                )\n            );\n    }\n\n    /**\n     * @notice Gets Actions typed data hash\n     * @param action the Action to retrieve\n     * @return actionHash actionHash the keccak Action hash\n     */\n    function getActionTypedDataHash(Action memory action, bytes32 DOMAIN_SEPARATOR)\n        internal\n        pure\n        returns (bytes32 actionHash)\n    {\n        actionHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, getActionStructHash(action)));\n    }\n\n    /**\n     * @notice Verifies that an action has been signed by the action.account.\n     * @param action The action to verify the signature for.\n     * @param signature Proof that the hash has been signed by action.account.\n     * @return True if the address recovered from the provided signature matches the action.account.\n     */\n    function isValidSignature(\n        Action memory action,\n        bytes memory signature,\n        bytes32 DOMAIN_SEPARATOR\n    ) internal pure returns (bool) {\n        if (signature.length != 65) return false;\n\n        bytes32 hash = getActionTypedDataHash(action, DOMAIN_SEPARATOR);\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := and(mload(add(signature, 65)), 255)\n        }\n\n        address recovered = ecrecover(hash, v, r, s);\n\n        return action.account == recovered;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title Interface of the Escrow.\n */\ninterface IEscrow {\n    function receiveFunding(uint256 loanId, uint256 amount) external;\n\n    function transferFundingNFT(\n        uint256 investmentId,\n        uint256 partitionsPurchased,\n        address receiver\n    ) external;\n\n    function transferLendingToken(address seeker, uint256 amount) external;\n\n    function transferProjectToken(\n        address projectToken,\n        address seeker,\n        uint256 amount\n    ) external;\n\n    function mintReputationalToken(address recipient, uint256 amount) external;\n\n    function burnReputationalToken(address from, uint256 amount) external;\n\n    function multiMintReputationalToken(address[] memory recipients, uint256[] memory amounts) external;\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title Interface of the Staking contract.\n */\ninterface IStaking {\n    function getBalance(address staker_) external view returns (uint256);\n\n    function getAmountsToStake()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getEligibilityForActionProvision(address account) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/libs/BytesReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @title Bytes Reader Library\n */\nlibrary BytesReader {\n    /**\n     * @notice Reads a bytes32 value from a position in a byte array.\n     * @param b Byte array containing a bytes32 value.\n     * @param index Index in byte array of bytes32 value.\n     * @return result bytes32 value from byte array.\n     */\n    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n        if (b.length < index + 32) {\n            return bytes32(0);\n        }\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, index))\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./staking/StakingDetails.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title AllianceBlock Staking contract\n * @notice Responsible for ALBT Staking\n * @dev Extends  Initializable, StakingDetails, OwnableUpgradeable\n */\ncontract Staking is Initializable, StakingDetails, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Initialize\n     * @dev Initialize of the contract.\n     * @param albt_ the albt IERC20 token\n     * @param escrow_ the escrow address\n     * @param stakingTypeAmounts_ the array of Staking Type Amounts\n     * @param reputationalStakingTypeAmounts_ the array of Reputation Staking Type Amounts\n     */\n    function initialize(\n        IERC20 albt_,\n        address escrow_,\n        uint256[] memory stakingTypeAmounts_,\n        uint256[] memory reputationalStakingTypeAmounts_\n    ) public initializer {\n        __Ownable_init();\n        albt = albt_;\n        escrow = IEscrow(escrow_);\n\n        for (uint256 i = 0; i < stakingTypeAmounts_.length; i++) {\n            stakingTypeAmounts[i] = stakingTypeAmounts_[i];\n        }\n\n        for (uint256 i = 0; i < reputationalStakingTypeAmounts_.length; i++) {\n            reputationalStakingTypeAmounts[i] = reputationalStakingTypeAmounts_[i];\n        }\n    }\n\n    /**\n     * @notice Stake\n     * @param stakingType The staking type\n     * @dev requires not Delegator and cannot repeat staking type\n     */\n    function stake(StakingType stakingType) public {\n        require(balance[msg.sender] < stakingTypeAmounts[uint256(stakingType)], \"Cannot stake for same type again\");\n        uint256 amount = stakingTypeAmounts[uint256(stakingType)];\n        require(amount > 0, \"Unsupported Staking type\");\n\n        uint256 stakingTypeIndex = _getStakingType(msg.sender);\n\n        _applyReputation(msg.sender, stakingTypeIndex, uint256(stakingType).add(1));\n\n        uint256 amountToStake = amount.sub(balance[msg.sender]);\n        _stake(msg.sender, amountToStake);\n        emit Staked(msg.sender, amountToStake);\n    }\n\n    /**\n     * @notice Unstake\n     * @param stakingType The staking type to drop to\n     * @dev msg.sender withdraws till reaching stakingType\n     */\n    function unstake(StakingType stakingType) external {\n        require(balance[msg.sender] > stakingTypeAmounts[uint256(stakingType)], \"Can only drop to lower level\");\n        require(uint256(stakingType) >= 0, \"Unsupported staking type\");\n\n        uint256 stakingTypeIndex = _getStakingType(msg.sender);\n        uint256 amount = stakingTypeAmounts[uint256(stakingType)];\n\n        _applyReputation(msg.sender, stakingTypeIndex, uint256(stakingType).add(1));\n\n        uint256 amountToWithdraw = balance[msg.sender].sub(amount);\n\n        _withdraw(msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @notice Exit\n     * @dev msg.sender withdraws and exits\n     */\n    function exit() external {\n        uint256 stakingTypeIndex = _getStakingType(msg.sender);\n\n        _applyReputation(msg.sender, stakingTypeIndex, 0);\n\n        uint256 amountToWithdraw = balance[msg.sender];\n\n        _withdraw(msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @notice Returns true if account is staker Lvl2 or more\n     * @param account The staker to check for\n     */\n    function getEligibilityForActionProvision(address account) external view returns (bool) {\n        if (balance[account] >= stakingTypeAmounts[1]) return true;\n        return false;\n    }\n\n    /**\n     * @notice Get Staking Type\n     * @param account the address\n     * @return the staking type\n     */\n    function _getStakingType(address account) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (balance[account] == stakingTypeAmounts[i]) {\n                return i.add(1);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Apply Reputation\n     * @param account the address\n     * @param previousLevelIndex The index of the previous level\n     * @param newLevelIndex the index for the new level\n     */\n    function _applyReputation(\n        address account,\n        uint256 previousLevelIndex,\n        uint256 newLevelIndex\n    ) internal {\n        if (previousLevelIndex < newLevelIndex) {\n            uint256 amountToMint = _findAmount(newLevelIndex, previousLevelIndex);\n            escrow.mintReputationalToken(account, amountToMint);\n        } else {\n            uint256 amountToBurn = _findAmount(previousLevelIndex, newLevelIndex);\n            escrow.burnReputationalToken(account, amountToBurn);\n        }\n    }\n\n    /**\n     * @notice Find Amount\n     * @param bigIndex ???\n     * @param smallIndex ???\n     * @return amount of reputation\n     */\n    function _findAmount(uint256 bigIndex, uint256 smallIndex) internal view returns (uint256 amount) {\n        if (smallIndex == 0) {\n            amount = reputationalStakingTypeAmounts[bigIndex.sub(1)];\n        } else {\n            amount = reputationalStakingTypeAmounts[bigIndex.sub(1)].sub(\n                reputationalStakingTypeAmounts[smallIndex.sub(1)]\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/staking/StakingDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./StakingTypesAndStorage.sol\";\n\n/**\n * @title Alliance Block Staking Details\n * @dev Extends StakingTypesAndStorage\n */\ncontract StakingDetails is StakingTypesAndStorage {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Withdraw\n     * @param staker_ the address of the staker\n     * @param amount_ the amount of ALBT to withdraw\n     */\n    function _withdraw(address staker_, uint256 amount_) internal {\n        totalSupply = totalSupply.sub(amount_);\n        balance[staker_] = balance[staker_].sub(amount_);\n        albt.transfer(staker_, amount_);\n        emit Withdrawn(staker_, amount_);\n    }\n\n    /**\n     * @notice Stake\n     * @param staker_ the address of the staker\n     * @param amount_ the amount of ALBT to withdraw\n     */\n    function _stake(address staker_, uint256 amount_) internal {\n        albt.transferFrom(staker_, address(this), amount_);\n        totalSupply = totalSupply.add(amount_);\n        balance[staker_] = balance[staker_].add(amount_);\n        emit Staked(staker_, amount_);\n    }\n\n    /**\n     * @notice Get Balance\n     * @dev Retrieves the staked balance for a given user\n     * @param staker_ the address of the staker\n     */\n    function getBalance(address staker_) external view returns (uint256) {\n        return balance[staker_];\n    }\n\n    /**\n     * @notice Get Amounts to Stake\n     * @return stakerLvl1Amount Staker lvl 1 Amount\n     * @return stakerLvl2Amount Staker lvl 2 Amount\n     * @return stakerLvl3Amount Staker lvl 3 Amount\n     */\n    function getAmountsToStake()\n        external\n        view\n        returns (\n            uint256 stakerLvl1Amount,\n            uint256 stakerLvl2Amount,\n            uint256 stakerLvl3Amount\n        )\n    {\n        stakerLvl1Amount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_1)];\n        stakerLvl2Amount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_2)];\n        stakerLvl3Amount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_3)];\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/StakingTypesAndStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IEscrow.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title AllianceBlock StakingStorage contract\n * @notice Responsible for staking storage\n */\ncontract StakingTypesAndStorage {\n    enum StakingType {STAKER_LVL_1, STAKER_LVL_2, STAKER_LVL_3}\n\n    // ALBT token\n    IERC20 public albt;\n    IEscrow public escrow;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balance;\n    mapping(uint256 => uint256) public stakingTypeAmounts; // Amounts required for each staking type.\n    mapping(uint256 => uint256) public reputationalStakingTypeAmounts; // Amounts of rALBT provided for each staking type.\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n}\n"
    },
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./registry/Investment.sol\";\nimport \"./libs/TokenFormat.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title AllianceBlock Registry contract\n * @notice Responsible for investment transactions.\n * @dev Extends Initializable, Investment, OwnableUpgradeable\n */\ncontract Registry is Initializable, Investment, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    // Events\n    event InvestmentStarted(uint256 indexed investmentId);\n    event InvestmentApproved(uint256 indexed investmentId);\n    event InvestmentRejected(uint256 indexed investmentId);\n\n    /**\n     * @notice Initialize\n     * @dev Constructor of the contract.\n     * @param escrowAddress address of the escrow contract\n     * @param governanceAddress_ address of the DAO contract\n     * @param lendingToken_ address of the Lending Token\n     * @param fundingNFT_ address of the Funding NFT\n     * @param baseAmountForEachPartition_ The base amount for each partition\n     */\n    function initialize(\n        address escrowAddress,\n        address governanceAddress_,\n        address lendingToken_,\n        address fundingNFT_,\n        uint256 baseAmountForEachPartition_\n    ) public initializer {\n        __Ownable_init();\n        escrow = IEscrow(escrowAddress);\n        baseAmountForEachPartition = baseAmountForEachPartition_;\n        governance = IGovernance(governanceAddress_);\n        lendingToken = IERC20(lendingToken_);\n        fundingNFT = IERC1155Mint(fundingNFT_);\n    }\n\n    /**\n     * @notice Initialize Investment\n     * @dev This function is called by the owner to initialize the investment type.\n     * @param reputationalAlbt The address of the rALBT contract.\n     * @param totalTicketsPerRun_ The amount of tickets that will be provided from each run of the lottery.\n     * @param rAlbtPerLotteryNumber_ The amount of rALBT needed to allocate one lucky number.\n     * @param blocksLockedForReputation_ The amount of blocks needed for a ticket to be locked,\n     *        so as investor to get 1 rALBT for locking it.\n     */\n    function initializeInvestment(\n        address reputationalAlbt,\n        uint256 totalTicketsPerRun_,\n        uint256 rAlbtPerLotteryNumber_,\n        uint256 blocksLockedForReputation_,\n        uint256 lotteryNumbersForImmediateTicket_\n    ) external onlyOwner() {\n        require(totalTicketsPerRun == 0, \"Cannot initialize twice\");\n        rALBT = IERC20(reputationalAlbt);\n        totalTicketsPerRun = totalTicketsPerRun_;\n        rAlbtPerLotteryNumber = rAlbtPerLotteryNumber_;\n        blocksLockedForReputation = blocksLockedForReputation_;\n        lotteryNumbersForImmediateTicket = lotteryNumbersForImmediateTicket_;\n    }\n\n    /**\n     * @notice Decide For Investment\n     * @dev This function is called by governance to approve or reject a investment request.\n     * @param investmentId The id of the investment.\n     * @param decision The decision of the governance. [true -> approved] [false -> rejected]\n     */\n    function decideForInvestment(uint256 investmentId, bool decision) external onlyGovernance() {\n        if (decision) _approveInvestment(investmentId);\n        else _rejectInvestment(investmentId);\n    }\n\n    /**\n     * @notice Start Lottery Phase\n     * @dev This function is called by governance to start the lottery phase for an investment.\n     * @param investmentId The id of the investment.\n     */\n    function startLotteryPhase(uint256 investmentId) external onlyGovernance() {\n        _startInvestment(investmentId);\n    }\n\n    /**\n     * @notice Approve Investment\n     * @param investmentId_ The id of the investment.\n     */\n    function _approveInvestment(uint256 investmentId_) internal {\n        projectStatus[investmentId_] = ProjectLibrary.ProjectStatus.APPROVED;\n        investmentDetails[investmentId_].approvalDate = block.timestamp;\n        fundingNFT.unpauseTokenTransfer(investmentId_); //UnPause trades for ERC1155s with the specific investment ID.\n        ticketsRemaining[investmentId_] = investmentDetails[investmentId_].totalPartitionsToBePurchased;\n        governance.storeInvestmentTriggering(investmentId_);\n        emit InvestmentApproved(investmentId_);\n    }\n\n    /**\n     * @notice Reject Investment\n     * @param investmentId_ The id of the investment.\n     */\n    function _rejectInvestment(uint256 investmentId_) internal {\n        projectStatus[investmentId_] = ProjectLibrary.ProjectStatus.REJECTED;\n        escrow.transferProjectToken(\n            investmentDetails[investmentId_].projectToken,\n            investmentSeeker[investmentId_],\n            investmentDetails[investmentId_].projectTokensAmount\n        );\n        emit InvestmentRejected(investmentId_);\n    }\n\n    /**\n     * @notice Start Investment\n     * @param investmentId_ The id of the investment.\n     */\n    function _startInvestment(uint256 investmentId_) internal {\n        projectStatus[investmentId_] = ProjectLibrary.ProjectStatus.STARTED;\n        investmentDetails[investmentId_].startingDate = block.timestamp;\n\n        emit InvestmentStarted(investmentId_);\n    }\n\n    /**\n     * @notice Get Investment Metadata\n     * @dev This helper function provides a single point for querying the Investment metadata\n     * @param investmentId The id of the investment.\n     * @dev returns Investment Details, Investment Status, Investment Seeker Address and Repayment Batch Type\n     */\n    function getInvestmentMetadata(uint256 investmentId)\n        public\n        view\n        returns (\n            ProjectLibrary.InvestmentDetails memory, // the investmentDetails\n            ProjectLibrary.ProjectStatus, // the projectStatus\n            address // the investmentSeeker\n        )\n    {\n        return (\n            investmentDetails[investmentId],\n            projectStatus[investmentId],\n            investmentSeeker[investmentId]\n        );\n    }\n}\n"
    },
    "contracts/registry/Investment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./InvestmentDetails.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title AllianceBlock Investment contract.\n * @notice Functionality for Investment.\n * @dev Extends InvestmentDetails.\n */\ncontract Investment is InvestmentDetails {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    // EVENTS\n    event InvestmentRequested(uint256 indexed investmentId, address indexed user, uint256 amount);\n\n    /**\n     * @notice Requests investment\n     * @dev This function is used for projects to request investment in exchange for project tokens.\n     * @dev require valid amount\n     * @param investmentToken The token that will be purchased by investors.\n     * @param amountOfInvestmentTokens The amount of investment tokens to be purchased.\n     * @param totalAmountRequested_ The total amount requested so as all investment tokens to be sold.\n     * @param extraInfo The ipfs hash where more specific details for investment request are stored.\n     */\n    function requestInvestment(\n        address investmentToken,\n        uint256 amountOfInvestmentTokens,\n        uint256 totalAmountRequested_,\n        string memory extraInfo\n    ) external {\n        // TODO - Change 10 ** 18 to decimals if needed.\n        require(\n            totalAmountRequested_.mod(baseAmountForEachPartition) == 0 &&\n                totalAmountRequested_.mul(10**18).mod(amountOfInvestmentTokens) == 0,\n            \"Token amount and price should result in integer amount of tickets\"\n        );\n\n        _storeInvestmentDetails(\n            totalAmountRequested_,\n            investmentToken,\n            amountOfInvestmentTokens,\n            extraInfo\n        );\n\n        IERC20(investmentToken).transferFrom(msg.sender, address(escrow), amountOfInvestmentTokens);\n\n        fundingNFT.mintGen0(address(escrow), investmentDetails[totalInvestments].totalPartitionsToBePurchased, totalInvestments);\n\n        investmentTokensPerTicket[totalInvestments] = amountOfInvestmentTokens.div(investmentDetails[totalInvestments].totalPartitionsToBePurchased);\n\n        fundingNFT.pauseTokenTransfer(totalInvestments); //Pause trades for ERC1155s with the specific investment ID.\n\n        governance.requestApproval(totalInvestments);\n\n        // Add event for investment request\n        emit InvestmentRequested(totalInvestments, msg.sender, totalAmountRequested_);\n\n        totalInvestments = totalInvestments.add(1);\n    }\n\n    /**\n     * @notice user show interest for investment\n     * @dev This function is called by the investors who are interested to invest in a specific project.\n     * @dev require Approval state and valid partition\n     * @param investmentId The id of the investment.\n     * @param amountOfPartitions The amount of partitions this specific investor wanna invest in.\n     */\n    function showInterestForInvestment(uint256 investmentId, uint256 amountOfPartitions) external {\n        require(\n            projectStatus[investmentId] == ProjectLibrary.ProjectStatus.APPROVED,\n            \"Can show interest only in Approved state\"\n        );\n        require(amountOfPartitions > 0, \"Cannot show interest for 0 partitions\");\n\n        lendingToken.transferFrom(msg.sender, address(escrow), amountOfPartitions.mul(baseAmountForEachPartition));\n\n        investmentDetails[investmentId].partitionsRequested = investmentDetails[investmentId].partitionsRequested.add(\n            amountOfPartitions\n        );\n\n        uint256 reputationalBalance = _updateReputationalBalanceForPreviouslyLockedTokens();\n        uint256 totalLotteryNumbers = reputationalBalance.div(rAlbtPerLotteryNumber);\n\n        if (totalLotteryNumbers == 0) revert(\"Not elegible for lottery numbers\");\n\n        uint256 immediateTickets;\n\n        // TODO - Explain this check to Rachid.\n        if (totalLotteryNumbers > lotteryNumbersForImmediateTicket) {\n            uint256 rest = totalLotteryNumbers.mod(lotteryNumbersForImmediateTicket);\n            immediateTickets = totalLotteryNumbers.sub(rest).div(lotteryNumbersForImmediateTicket);\n            totalLotteryNumbers = rest;\n        }\n\n        if (immediateTickets > amountOfPartitions) immediateTickets = amountOfPartitions;\n\n        // Just in case we provided immediate tickets and tickets finished, so there is no lottery in this case.\n        if (immediateTickets > ticketsRemaining[investmentId]) {\n            immediateTickets = ticketsRemaining[investmentId];\n            projectStatus[investmentId] = ProjectLibrary.ProjectStatus.SETTLED;\n\n            return;\n        }\n\n        if (immediateTickets > 0) {\n            ticketsWonPerAddress[investmentId][msg.sender] = immediateTickets;\n            ticketsRemaining[investmentId] = ticketsRemaining[investmentId].sub(immediateTickets);\n        }\n\n        remainingTicketsPerAddress[investmentId][msg.sender] = amountOfPartitions.sub(immediateTickets);\n\n        uint256 maxLotteryNumber = totalLotteryNumbersPerInvestment[investmentId].add(totalLotteryNumbers);\n\n        for (uint256 i = totalLotteryNumbersPerInvestment[investmentId].add(1); i <= maxLotteryNumber; i++) {\n            addressOfLotteryNumber[investmentId][i] = msg.sender;\n        }\n\n        totalLotteryNumbersPerInvestment[investmentId] = maxLotteryNumber;\n    }\n\n    /**\n     * @notice Executes lottery run\n     * @dev This function is called by any investor interested in a project to run part of the lottery.\n     * @dev requires Started state and available tickets\n     * @param investmentId The id of the investment.\n     */\n    function executeLotteryRun(uint256 investmentId) external {\n        require(projectStatus[investmentId] == ProjectLibrary.ProjectStatus.STARTED, \"Can run lottery only in Started state\");\n        require(\n            remainingTicketsPerAddress[investmentId][msg.sender] > 0,\n            \"Can run lottery only if has remaining ticket\"\n        );\n\n        ticketsWonPerAddress[investmentId][msg.sender] = ticketsWonPerAddress[investmentId][msg.sender].add(1);\n        remainingTicketsPerAddress[investmentId][msg.sender] = remainingTicketsPerAddress[investmentId][msg.sender].sub(\n            1\n        );\n        ticketsRemaining[investmentId] = ticketsRemaining[investmentId].sub(1);\n\n        uint256 counter = totalTicketsPerRun;\n        uint256 maxNumber = totalLotteryNumbersPerInvestment[investmentId];\n\n        if (ticketsRemaining[investmentId] <= counter) {\n            projectStatus[investmentId] = ProjectLibrary.ProjectStatus.SETTLED;\n            counter = ticketsRemaining[investmentId];\n            ticketsRemaining[investmentId] = 0;\n        } else {\n            ticketsRemaining[investmentId] = ticketsRemaining[investmentId].sub(counter);\n        }\n\n        for (uint256 i = counter; i > 0; i--) {\n            uint256 randomNumber = _getRandomNumber(maxNumber);\n            lotteryNonce = lotteryNonce.add(1);\n\n            address randomAddress = addressOfLotteryNumber[investmentId][randomNumber.add(1)];\n\n            if (remainingTicketsPerAddress[investmentId][randomAddress] > 0) {\n                remainingTicketsPerAddress[investmentId][randomAddress] = remainingTicketsPerAddress[investmentId][\n                    randomAddress\n                ]\n                    .sub(1);\n\n                ticketsWonPerAddress[investmentId][randomAddress] = ticketsWonPerAddress[investmentId][randomAddress]\n                    .add(1);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw Investment Tickets\n     * @dev This function is called by an investor to withdraw his tickets.\n     * @dev require Settled state and enough tickets won\n     * @param investmentId The id of the investment.\n     * @param ticketsToLock The amount of won tickets to be locked, so as to get more rALBT.\n     * @param ticketsToWithdraw The amount of won tickets to be withdrawn instantly.\n     */\n    function withdrawInvestmentTickets(\n        uint256 investmentId,\n        uint256 ticketsToLock,\n        uint256 ticketsToWithdraw\n    ) external {\n        require(projectStatus[investmentId] == ProjectLibrary.ProjectStatus.SETTLED, \"Can withdraw only in Settled state\");\n        require(\n            ticketsWonPerAddress[investmentId][msg.sender] > 0 &&\n                ticketsWonPerAddress[investmentId][msg.sender] >= ticketsToLock.add(ticketsToWithdraw),\n            \"Not enough tickets won\"\n        );\n\n        ticketsWonPerAddress[investmentId][msg.sender] = ticketsWonPerAddress[investmentId][msg.sender]\n            .sub(ticketsToLock)\n            .sub(ticketsToWithdraw);\n\n        _updateReputationalBalanceForPreviouslyLockedTokens();\n\n        if (ticketsToLock > 0) {\n            lockedTicketsForSpecificInvestmentPerAddress[investmentId][\n                msg.sender\n            ] = lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender].add(ticketsToLock);\n\n            lockedTicketsPerAddress[msg.sender] = lockedTicketsPerAddress[msg.sender].add(ticketsToLock);\n        }\n\n        if (ticketsToWithdraw > 0) {\n            uint256 amountToWithdraw = investmentTokensPerTicket[investmentId].mul(ticketsToWithdraw);\n            escrow.transferProjectToken(investmentDetails[investmentId].projectToken, msg.sender, amountToWithdraw);\n        }\n\n        if (remainingTicketsPerAddress[investmentId][msg.sender] > 0) {\n            _withdrawAmountProvidedForNonWonTickets(investmentId);\n        }\n    }\n\n    /**\n     * @dev This function is called by an investor to withdraw lending tokens provided for non-won tickets.\n     * @param investmentId The id of the investment.\n     */\n    function withdrawAmountProvidedForNonWonTickets(uint256 investmentId) external {\n        require(projectStatus[investmentId] == ProjectLibrary.ProjectStatus.SETTLED, \"Can withdraw only in Settled state\");\n        require(remainingTicketsPerAddress[investmentId][msg.sender] > 0, \"No non-won tickets to withdraw\");\n\n        _withdrawAmountProvidedForNonWonTickets(investmentId);\n    }\n\n    /**\n     * @notice Withdraw locked investment ticket.\n     * @dev This function is called by an investor to withdraw his locked tickets.\n     * @dev requires Settled state and available tickets.\n     * @param investmentId The id of the investment.\n     * @param ticketsToWithdraw The amount of locked tickets to be withdrawn.\n     */\n    function withdrawLockedInvestmentTickets(uint256 investmentId, uint256 ticketsToWithdraw) external {\n        require(projectStatus[investmentId] == ProjectLibrary.ProjectStatus.SETTLED, \"Can withdraw only in Settled state\");\n        require(\n            ticketsToWithdraw > 0 &&\n                lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender] >= ticketsToWithdraw,\n            \"Not enough tickets to withdraw\"\n        );\n\n        _updateReputationalBalanceForPreviouslyLockedTokens();\n\n        lockedTicketsForSpecificInvestmentPerAddress[investmentId][\n            msg.sender\n        ] = lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender].sub(ticketsToWithdraw);\n\n        lockedTicketsPerAddress[msg.sender] = lockedTicketsPerAddress[msg.sender].sub(ticketsToWithdraw);\n\n        uint256 amountToWithdraw = investmentTokensPerTicket[investmentId].mul(ticketsToWithdraw);\n        escrow.transferProjectToken(investmentDetails[investmentId].projectToken, msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @notice Gets Requesting status\n     * @dev Returns true if investors have shown interest for equal or more than the total tickets.\n     * @param investmentId The id of the investment type to be checked.\n     */\n    function getRequestingInterestStatus(uint256 investmentId) external view returns (bool) {\n        return investmentDetails[investmentId].totalPartitionsToBePurchased <= investmentDetails[investmentId].partitionsRequested;\n    }\n\n    /**\n     * @notice Generates Random Number\n     * @dev This function generates a random number\n     * @param maxNumber the max number possible\n     * @return randomNumber the random number generated\n     */\n    function _getRandomNumber(uint256 maxNumber) internal view returns (uint256 randomNumber) {\n        randomNumber = uint256(\n            keccak256(\n                abi.encodePacked(block.difficulty, block.timestamp, lotteryNonce, blockhash(block.number), msg.sender)\n            )\n        )\n            .mod(maxNumber);\n    }\n\n    /**\n     * @notice Updates reputation balance\n     * @dev updates balance of reputation for locked tokens\n     * @return the reputation balance of msg.sender\n     */\n    function _updateReputationalBalanceForPreviouslyLockedTokens() internal returns (uint256) {\n        if (lockedTicketsPerAddress[msg.sender] > 0) {\n            uint256 amountOfReputationalAlbtPerTicket =\n                (block.number.sub(lastBlockCheckedForLockedTicketsPerAddress[msg.sender])).div(\n                    blocksLockedForReputation\n                );\n\n            uint256 amountOfReputationalAlbtToMint =\n                amountOfReputationalAlbtPerTicket.mul(lockedTicketsPerAddress[msg.sender]);\n\n            if (amountOfReputationalAlbtToMint > 0)\n                escrow.mintReputationalToken(msg.sender, amountOfReputationalAlbtToMint);\n\n            lastBlockCheckedForLockedTicketsPerAddress[msg.sender] = block.number;\n        }\n\n        return rALBT.balanceOf(msg.sender);\n    }\n\n    function _withdrawAmountProvidedForNonWonTickets(uint256 investmentId_) internal {\n        uint256 amountToReturnForNonWonTickets =\n            remainingTicketsPerAddress[investmentId_][msg.sender].mul(baseAmountForEachPartition);\n        remainingTicketsPerAddress[investmentId_][msg.sender] = 0;\n\n        escrow.transferLendingToken(msg.sender, amountToReturnForNonWonTickets);\n    }\n}\n"
    },
    "contracts/libs/TokenFormat.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.0;\n\n/**\n * @title The Token Format library\n */\nlibrary TokenFormat {\n    // Use a split bit implementation.\n    // Store the generation in the upper 128 bits..\n    // ..and the non-fungible loan id in the lower 128\n    uint256 private constant _LOAN_ID_MASK = uint128(~0);\n\n    /**\n     * @notice Format tokenId into generation and index\n     * @param tokenId The Id of the token\n     * @return generation\n     * @return loanId\n     */\n    function formatTokenId(uint256 tokenId) internal pure returns (uint256 generation, uint256 loanId) {\n        generation = tokenId >> 128;\n        loanId = tokenId & _LOAN_ID_MASK;\n    }\n\n    /**\n     * @notice get tokenId from generation and loanId\n     * @param gen the generation\n     * @param loanId the loanID\n     * @return tokenId the token id\n     */\n    function getTokenId(uint256 gen, uint256 loanId) internal pure returns (uint256 tokenId) {\n        return (gen << 128) | loanId;\n    }\n}\n"
    },
    "contracts/registry/InvestmentDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Storage.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title AllianceBlock InvestmentDetails contract\n * @notice Functionality for storing investment details and modifiers.\n * @dev Extends Storage\n */\ncontract InvestmentDetails is Storage {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    modifier onlyGovernance() {\n        require(msg.sender == address(governance), \"Only Governance\");\n        _;\n    }\n\n    /**\n     * @notice Stores Investment Details\n     * @dev require a valid interest percentage\n     * @param amountRequestedToBeRaised_ the amount requested\n     * @param projectToken_ the project token\n     * @param projectTokensAmount_ the amount of project tokens provided\n     * @param extraInfo_ the IPFS hard data provided\n     */\n    function _storeInvestmentDetails(\n        uint256 amountRequestedToBeRaised_,\n        address projectToken_,\n        uint256 projectTokensAmount_,\n        string memory extraInfo_\n    ) internal {\n        ProjectLibrary.InvestmentDetails memory investment;\n        investment.investmentId = totalInvestments;\n        investment.projectToken = projectToken_;\n        investment.projectTokensAmount = projectTokensAmount_;\n        investment.totalAmountToBeRaised = amountRequestedToBeRaised_;\n        investment.extraInfo = extraInfo_;\n        investment.totalPartitionsToBePurchased = amountRequestedToBeRaised_.div(baseAmountForEachPartition);\n\n        investmentDetails[totalInvestments] = investment;\n\n        projectStatus[totalInvestments] = ProjectLibrary.ProjectStatus.REQUESTED;\n        investmentSeeker[totalInvestments] = msg.sender;\n    }\n}\n"
    },
    "contracts/registry/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libs/ProjectLibrary.sol\";\nimport \"../interfaces/IERC1155Mint.sol\";\nimport \"../interfaces/IGovernance.sol\";\nimport \"../interfaces/IEscrow.sol\";\n\n/**\n * @title AllianceBlock Storage contract\n * @notice Responsible for investment storage\n */\ncontract Storage {\n    uint256 public totalInvestments; // The total amount of investment requests.\n\n    // Mapping from investment id -> details for each and every investment.\n    mapping(uint256 => ProjectLibrary.InvestmentDetails) public investmentDetails;\n    // Mapping from investment id -> investment status.\n    mapping(uint256 => ProjectLibrary.ProjectStatus) public projectStatus;\n    // Mapping from investment id -> investment seeker's address.\n    mapping(uint256 => address) public investmentSeeker;\n    // The amount of investment tokens each ticket contains.\n    mapping(uint256 => uint256) public investmentTokensPerTicket;\n    // The amount of tickets remaining to be allocated to investors.\n    mapping(uint256 => uint256) public ticketsRemaining;\n    // The number lottery numbers allocated from all investors for a specific investment.\n    mapping(uint256 => uint256) public totalLotteryNumbersPerInvestment;\n    // The address of the investor that has allocated a specific lottery number on a specific investment.\n    mapping(uint256 => mapping(uint256 => address)) public addressOfLotteryNumber;\n    // The amount of tickets that an investor requested that are still not allocated.\n    mapping(uint256 => mapping(address => uint256)) public remainingTicketsPerAddress;\n    // The amount of tickets that an investor requested that have been won already.\n    mapping(uint256 => mapping(address => uint256)) public ticketsWonPerAddress;\n    // The amount of tickets that an investor locked for a specific investment.\n    mapping(uint256 => mapping(address => uint256)) public lockedTicketsForSpecificInvestmentPerAddress;\n    // The amount of tickets that an investor locked from all investments.\n    mapping(address => uint256) public lockedTicketsPerAddress;\n    // The last block checked for rewards for the tickets locked per address.\n    mapping(address => uint256) public lastBlockCheckedForLockedTicketsPerAddress;\n\n    IGovernance public governance; // Governance's contract address.\n    IERC20 public lendingToken; // Lending token's contract address.\n    IERC1155Mint public fundingNFT; // Funding nft's contract address.\n    IEscrow public escrow; // Escrow's contract address.\n    IERC20 public rALBT; // rALBT's contract address.\n\n    // This variable represents the base amount in which every investment amount is divided to. (also the starting value for each ERC1155)\n    uint256 public baseAmountForEachPartition;\n    // The amount of tickets to be provided by each run of the lottery.\n    uint256 public totalTicketsPerRun;\n    // The amount of rALBT needed to allocate one lottery number.\n    uint256 public rAlbtPerLotteryNumber;\n    // The amount of blocks needed for a ticket to be locked, so as the investor to get 1 rALBT.\n    uint256 public blocksLockedForReputation;\n    // The amount of lottery numbers, that if investor has after number allocation he gets one ticket without lottery.\n    uint256 public lotteryNumbersForImmediateTicket;\n    // The nonce for the lottery numbers.\n    uint256 internal lotteryNonce;\n}\n"
    },
    "contracts/libs/ProjectLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.0;\n\n/**\n * @title Investment Library\n */\nlibrary InvestmentLibrary {\n    enum projectStatus {\n        REQUESTED, // Status when investment has been requested, but not approved yet.\n        APPROVED, // Status when investment has been approved from governors.\n        STARTED, // Status when investment has been fully funded.\n        SETTLED, // Status when investment has been fully repaid by the seeker.\n        DEFAULT, // Status when seeker has not been able to repay the investment.\n        REJECTED // Status when investment has been rejected by governors.\n    }\n\n    struct InvestmentDetails {\n        uint256 investmentId; // The Id of the investment.\n        uint256 approvalDate; // The timestamp in which investment was approved.\n        uint256 startingDate; // The timestamp in which investment was funded.\n        address projectToken; // The address of the token that will be sold to investors.\n        uint256 projectTokensAmount; // The amount of project tokens that are deposited for investors by the seeker.\n        uint256 totalAmountToBeRaised; // The amount of tokens that seeker of investment will raise after all tickets are purchased.\n        uint256 totalPartitionsToBePurchased; // The total partitions or ERC1155 tokens, in which investment is splitted.\n        string extraInfo; // The ipfs hash, where all extra info about the investment are stored.\n        uint256 partitionsRequested; // The total partitions or ERC1155 tokens that are requested for purchase.\n    }\n}\n"
    },
    "contracts/interfaces/IERC1155Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title Interface of the IERC1155 mint function.\n */\ninterface IERC1155Mint {\n    function mintGen0(\n        address to,\n        uint256 amount,\n        uint256 investmentId\n    ) external;\n\n    function mintOfGen(\n        address to,\n        uint256 amount,\n        uint256 generation,\n        uint256 investmentId\n    ) external;\n\n    function decreaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToDecrease\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function pauseTokenTransfer(uint256 investmentId) external;\n\n    function unpauseTokenTransfer(uint256 tokenId) external;\n\n    function increaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToAdd\n    ) external;\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title Interface of the Governance contract.\n */\ninterface IGovernance {\n    function requestApproval(\n        uint256 investmentId\n    ) external;\n\n    function storeInvestmentTriggering(uint256 investmentId) external;\n}\n"
    },
    "contracts/NFTs/FundingNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title Alliance Block Funding NFTs\n * @notice NFTs that will be held by users\n * @dev Extends Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC1155Upgradeable\n */\ncontract FundingNFT is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC1155Upgradeable {\n    using TokenFormat for uint256;\n\n    // Events\n    event GenerationIncreased(uint256 indexed investmentId, address indexed user, uint256 newGeneration);\n    event GenerationDecreased(uint256 indexed investmentId, address indexed user, uint256 newGeneration);\n    event TransfersPaused(uint256 investmentId);\n    event TransfersResumed(uint256 investmentId);\n\n    // contract URI for marketplaces\n    string private _contractURI;\n\n    // base url for each token metadata. Concatenates with ipfsHash for full path\n    string private _baseURI;\n\n    // Mapping from loan ID to paused condition\n    mapping(uint256 => bool) public transfersPaused;\n\n    // Mapping from token ID to IPFS hash (token metadata)\n    mapping(uint256 => string) public ipfsHashes;\n\n    // Access Roles\n    bytes32 public MINTER_ROLE;\n    bytes32 public PAUSER_ROLE;\n\n    /**\n     * @notice Initializes the contract\n     * @param baseUri sets the base URI\n     * @param contractUri sets the contract URI\n     */\n    function initialize(string memory baseUri, string memory contractUri) public initializer {\n        MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n        PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n        __ERC1155_init(\"\");\n        __ERC1155_init_unchained(\"\");\n        _baseURI = baseUri;\n        _contractURI = contractUri;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    modifier onlyPauser() {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"Must have pauser role\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"Must have minter role to mint\");\n        _;\n    }\n\n    /**\n     * @notice contract metadata\n     * @return the contractURI stored in memory\n     */\n    function contractURI() public view returns (string memory) {\n        return _contractURI;\n    }\n\n    /**\n     * @notice Pauses the token transfers\n     * @dev Owner can pause transfers for specific tokens\n     * @dev pauses all loan ids, no matter the generation\n     * @param investmentId the investment ID to be paused\n     */\n    function pauseTokenTransfer(uint256 investmentId) external onlyPauser {\n        transfersPaused[investmentId] = true;\n        emit TransfersPaused(investmentId);\n    }\n\n    /**\n     * @notice Unpauses the token transfers\n     * @dev Owner can unpause transfers for specific tokens\n     * @param investmentId the investment ID to be unpaused\n     */\n    function unpauseTokenTransfer(uint256 investmentId) external onlyPauser {\n        transfersPaused[investmentId] = false;\n        emit TransfersResumed(investmentId);\n    }\n\n    /**\n     * @notice Mint generation 0 tokens\n     * @param to the target address that will receive the Gen0 tokens\n     * @param amount the amount of tokens to mint\n     * @param investmentId the ID of the investment\n     */\n    function mintGen0(\n        address to,\n        uint256 amount,\n        uint256 investmentId\n    ) external onlyMinter {\n        // investmentId is the tokenId used to mint\n        _mint(to, investmentId, amount, \"\");\n    }\n\n    /**\n     * @notice Mint tokens of a specific generation directly\n     * @param to The address to mint the tokens to.\n     * @param amount The amount of tokens to mint.\n     * @param generation The generation of the tokens. The id of the tokens will be composed of the loan id and this generation number.\n     * @param investmentId The loan identifier\n     */\n    function mintOfGen(\n        address to,\n        uint256 amount,\n        uint256 generation,\n        uint256 investmentId\n    ) external onlyMinter {\n        uint256 tokenId = generation.getTokenId(investmentId);\n        _mint(to, tokenId, amount, \"\");\n    }\n\n    /**\n     * @notice Decrease generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     * @param tokenId the ID of the token to decrease generations\n     * @param user the owner of the tokens\n     * @param amount the number of tokens to change\n     * @param generationsToDecrease the number of generations to decrease\n     */\n    function decreaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToDecrease\n    ) external onlyMinter {\n        _decreaseGenerations(tokenId, user, amount, generationsToDecrease);\n    }\n\n    /**\n     * @notice increase generation of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     * @param tokenId the ID of the token to increase a single generation\n     * @param user the owner of the tokens\n     * @param amount the number of tokens to increase a single generation\n     */\n    function increaseGeneration(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external onlyMinter {\n        _increaseGenerations(tokenId, user, amount, 1);\n    }\n\n    /**\n     * @notice increase generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     * @param tokenId the ID of the token to increase generations\n     * @param user the owner of the tokens\n     * @param amount the number of tokens to increase generations\n     * @param generationsToAdd the number of generations to increase\n     */\n    function increaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToAdd\n    ) external onlyMinter {\n        _increaseGenerations(tokenId, user, amount, generationsToAdd);\n    }\n\n    /**\n     * @notice Burns tokens\n     * @param account the owner of the tokens\n     * @param id id of the token\n     * @param amount the number of tokens to burn\n     */\n    function burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) public onlyMinter {\n        _burn(account, id, amount);\n    }\n\n    /**\n     * @notice increase multiple generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     * @param tokenId the ID of the token to increase generations\n     * @param user the owner of the tokens\n     * @param amount the number of tokens to increase generations\n     * @param generationsToAdd the number of generations to increase\n     */\n    function _increaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToAdd\n    ) internal {\n        (uint256 generation, uint256 investmentId) = tokenId.formatTokenId();\n\n        // Increase generation, leave investmentId same\n        generation += generationsToAdd;\n        uint256 newTokenId = generation.getTokenId(investmentId);\n\n        // Burn previous gen tokens\n        burn(user, tokenId, amount);\n\n        // Mint new generation tokens\n        _mint(user, newTokenId, amount, \"\");\n\n        emit GenerationIncreased(investmentId, user, generation);\n    }\n\n    /**\n     * @notice decrease multiple generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     * @param tokenId the ID of the token to decrease generations\n     * @param user the owner of the tokens\n     * @param amount the number of tokens to decrease  Generations\n     * @param generationsToDecrease the number of generations to decrease\n     */\n    function _decreaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToDecrease\n    ) internal {\n        (uint256 generation, uint256 investmentId) = tokenId.formatTokenId();\n\n        require(generation >= generationsToDecrease, \"Invalid token ID\");\n\n        // Decrease generation, leave investmentId same\n        generation -= generationsToDecrease;\n        uint256 newTokenId = generation.getTokenId(investmentId);\n\n        // Burn previous gen tokens\n        burn(user, tokenId, amount);\n\n        // Mint new generation tokens\n        _mint(user, newTokenId, amount, \"\");\n\n        emit GenerationDecreased(investmentId, user, generation);\n    }\n\n    /**\n     * @notice Runs checks before transferring a token\n     * @dev Validates if the investmentId from the tokenId can be transferred and not paused\n     * @param operator TBD\n     * @param from TBD\n     * @param to TBD\n     * @param ids array of ids\n     * @param amounts array of amounts\n     * @param data TBD\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal view override {\n        for (uint256 i = 0; i < ids.length; i++) {\n            (, uint256 investmentId) = ids[i].formatTokenId();\n            require(!transfersPaused[investmentId], \"Transfers paused\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155MetadataURIUpgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSetUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using AddressUpgradeable for address;\n\n    struct RoleData {\n        EnumerableSetUpgradeable.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\n"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nlibrary Strings {\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        for (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    function __ERC1155Receiver_init_unchained() internal initializer {\n        _registerInterface(\n            ERC1155ReceiverUpgradeable(address(0)).onERC1155Received.selector ^\n            ERC1155ReceiverUpgradeable(address(0)).onERC1155BatchReceived.selector\n        );\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n        __ERC1155Holder_init_unchained();\n    }\n\n    function __ERC1155Holder_init_unchained() internal initializer {\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol\";\nimport \"./EscrowDetails.sol\";\nimport \"./rALBT.sol\";\n\n/**\n * @title AllianceBlock Escrow contract\n * @notice Responsible for handling the funds in AllianceBlock's ecosystem.\n * @dev Extends Initializable, EscrowDetails, OwnableUpgradeable, ERC1155HolderUpgradeable\n */\ncontract Escrow is Initializable, EscrowDetails, OwnableUpgradeable, ERC1155HolderUpgradeable {\n    /**\n     * @notice Initialize\n     * @dev Initializes the contract.\n     * @param lendingToken_ The token that lenders will be able to lend.\n     * @param fundingNFT_ The ERC1155 token contract which will represent the lending amounts.\n     */\n    function initialize(address lendingToken_, address fundingNFT_) public initializer {\n        __Ownable_init();\n        lendingToken = IERC20(lendingToken_);\n        fundingNFT = IERC1155Mint(fundingNFT_);\n        reputationalALBT = new rALBT();\n    }\n\n    /**\n     * @notice After Initialize\n     * @dev To be executed after Initialize\n     * @dev requires not already initialized\n     * @param registryAddress_ The registry address.\n     * @param actionVerifierAddress_ The actionVerifier address.\n     * @param stakingAddress_ The staking address\n     */\n    function afterInitialize(\n        address registryAddress_,\n        address actionVerifierAddress_,\n        address stakingAddress_\n    ) external onlyOwner() {\n        require(address(registry) == address(0), \"Cannot initialize registry second time\");\n        require(address(actionVerifier) == address(0), \"Cannot initialize actionVerifier second time\");\n        require(address(staking) == address(0), \"Cannot initialize staking second time\");\n        registry = IRegistry(registryAddress_);\n        actionVerifier = actionVerifierAddress_;\n        staking = stakingAddress_;\n    }\n\n    /**\n     * @notice Transfer Funding NFT\n     * @dev This function is used to send the ERC1155 tokens from escrow to the lenders.\n     * @param investmentId The id of the investment.\n     * @param partitionsPurchased The amount of ERC1155 tokens that should be sent back to the lender.\n     * @param receiver Lender's address.\n     */\n    function transferFundingNFT(\n        uint256 investmentId,\n        uint256 partitionsPurchased,\n        address receiver\n    ) external onlyRegistry() {\n        fundingNFT.safeTransferFrom(address(this), receiver, investmentId, partitionsPurchased, \"\");\n    }\n\n    /**\n     * @notice Transfer Lending Token\n     * @dev This function is used to send the lended amount to the seeker.\n     * @param seeker Seeker's address.\n     * @param amount The amount of lending tokens to be sent to seeker.\n     */\n    function transferLendingToken(address seeker, uint256 amount) external onlyRegistry() {\n        lendingToken.transfer(seeker, amount);\n    }\n\n    /**\n     * @notice Transfer Project Token\n     * @dev This function is used to send the project token amount to the seeker.\n     * @param projectToken The project token's contract address.\n     * @param recipient The address to transfer the project tokens to.\n     * @param amount The amount of project tokens to be sent to seeker.\n     */\n    function transferProjectToken(\n        address projectToken,\n        address recipient,\n        uint256 amount\n    ) external onlyRegistry() {\n        IERC20(projectToken).transfer(recipient, amount);\n    }\n\n    /**\n     * @notice Multi Mint Reputation Token\n     * @dev This function is used to multi mint reputational tokens.\n     * @param recipients The addresses to mint the reputational tokens to.\n     * @param amounts The amounts of reputational tokens to be minted.\n     */\n    function multiMintReputationalToken(address[] memory recipients, uint256[] memory amounts)\n        external\n        onlyActionVerifier()\n    {\n        reputationalALBT.multiMintTo(recipients, amounts);\n    }\n\n    /**\n     * @notice Mint Reputation Token\n     * @dev This function is used to mint reputational tokens.\n     * @param recipient The address to mint the reputational tokens to.\n     * @param amount The amount of reputational tokens to be minted.\n     */\n    function mintReputationalToken(address recipient, uint256 amount) external onlyRegistryOrStaking() {\n        reputationalALBT.mintTo(recipient, amount);\n    }\n\n    /**\n     * @notice Burn Reputation token\n     * @dev This function is used to burn reputational tokens.\n     * @param from The address to burn the reputational tokens from.\n     * @param amount The amount of reputational tokens to be burnt.\n     */\n    function burnReputationalToken(address from, uint256 amount) external onlyStaking() {\n        reputationalALBT.burnFrom(from, amount);\n    }\n\n    /**\n     * @notice Change Registry\n     * @dev This function is used to change the registry address in case of an upgrade.\n     * @param registryAddress The address of the upgraded Registry contract.\n     */\n    function changeRegistry(address registryAddress) external onlyOwner() {\n        registry = IRegistry(registryAddress);\n    }\n}\n"
    },
    "contracts/EscrowDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IERC1155Mint.sol\";\nimport \"./interfaces/IERC721Mint.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./rALBT.sol\";\n\n/**\n * @title AllianceBlock EscrowDetails contract\n * @notice Functionality, storage and modifiers for Escrow\n */\ncontract EscrowDetails {\n    IRegistry public registry;\n\n    IERC20 public lendingToken;\n    IERC1155Mint public fundingNFT;\n    address public actionVerifier;\n    address public staking;\n\n    mapping(uint256 => address) public investmentSeeker;\n    rALBT public reputationalALBT;\n\n    modifier onlyRegistry() {\n        require(msg.sender == address(registry), \"Only Registry\");\n        _;\n    }\n\n    modifier onlyActionVerifier() {\n        require(msg.sender == actionVerifier, \"Only Action Verifier\");\n        _;\n    }\n\n    modifier onlyStaking() {\n        require(msg.sender == staking, \"Only Staking\");\n        _;\n    }\n\n    modifier onlyRegistryOrStaking() {\n        require(msg.sender == staking || msg.sender == address(registry), \"Only Registry or Staking\");\n        _;\n    }\n}\n"
    },
    "contracts/rALBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title AllianceBlock Reputation Token contract\n * @dev Extends Ownable\n */\ncontract rALBT is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    string constant NAME = \"Reputational AllianceBlock Token\"; // The name of the token\n    string constant SYMBOL = \"rALBT\"; // The symbol of the token\n    uint256 _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    /**\n     * @notice Multi Mint To\n     * @dev Multimints tokens.\n     * @dev Requires valid lists\n     * @param to The addresses that will be minted tokens.\n     * @param amounts The amounts of tokens to be minted.\n     */\n    function multiMintTo(address[] memory to, uint256[] memory amounts) external onlyOwner() {\n        require(to.length == amounts.length, \"Invalid length of to or amounts\");\n\n        for (uint256 i = 0; i < to.length; i++) {\n            if (to[i] != address(0)) _mint(to[i], amounts[i]);\n        }\n    }\n\n    /**\n     * @notice Mint To\n     * @dev Mints amountToMint tokens to the sender\n     * @param amountToMint The amount of tokens to be minted\n     */\n    function mintTo(address to, uint256 amountToMint) external onlyOwner() {\n        _mint(to, amountToMint);\n    }\n\n    /**\n     * @notice Burn From\n     * @dev Burns amountToBurn tokens from the sender\n     * @param amountToBurn The amount of tokens to be burnt\n     */\n    function burnFrom(address from, uint256 amountToBurn) external onlyOwner() {\n        _burn(from, amountToBurn);\n    }\n\n    /**\n     * @notice Name\n     * @dev Returns the name of the token.\n     */\n    function name() public pure returns (string memory) {\n        return NAME;\n    }\n\n    /**\n     * @notice Symbol\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public pure returns (string memory) {\n        return SYMBOL;\n    }\n\n    /**\n     * @notice Decimals\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Total Supply\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @notice Balance Of\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @notice Mint\n     * @dev requires not to zero address\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice Burn\n     * @dev requires not from zero address\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n}\n"
    },
    "contracts/interfaces/IERC721Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title Interface of the IERC721 mint function.\n */\ninterface IERC721Mint {\n    function mint(address to) external;\n}\n"
    },
    "contracts/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title Interface of the Registry contract.\n */\ninterface IRegistry {\n    function decideForInvestment(uint256 investmentId, bool decision) external;\n\n    function getRequestingInterestStatus(uint256 investmentId) external view returns (bool);\n\n    function startLotteryPhase(uint256 investmentId) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../token/ERC20/ERC20.sol\";\nimport \"../token/ERC20/ERC20Burnable.sol\";\nimport \"../token/ERC20/ERC20Pausable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControl, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/mocks/ProjectToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n * @dev Extends ERC20PresetMinterPauser\n */\ncontract ProjectToken is ERC20PresetMinterPauser {\n    constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}\n}\n"
    },
    "contracts/mocks/LendingToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for Lending ERC20 Token\n * @dev Extends ERC20PresetMinterPauser\n */\ncontract LendingToken is ERC20PresetMinterPauser {\n    constructor() ERC20PresetMinterPauser(\"Lending Token USDC\", \"USDC\") {}\n}\n"
    },
    "contracts/mocks/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n * @dev Extends ERC20PresetMinterPauser\n */\ncontract CollateralToken is ERC20PresetMinterPauser {\n    constructor() ERC20PresetMinterPauser(\"Collateral Token\", \"CLT\") {}\n}\n"
    },
    "contracts/mocks/ALBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n * @dev Extends ERC20PresetMinterPauser\n */\ncontract ALBT is ERC20PresetMinterPauser {\n    constructor() ERC20PresetMinterPauser(\"AllianceBlock Token\", \"ALBT\") {}\n}\n"
    },
    "contracts/governance/DaoCronjob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./GovernanceTypesAndStorage.sol\";\nimport \"../interfaces/IRegistry.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @dev Extends GovernanceTypesAndStorage\n * @notice Responsible for governing AllianceBlock's ecosystem\n */\ncontract DaoCronjob is GovernanceTypesAndStorage {\n    using SafeMath for uint256;\n    using ValuedDoubleLinkedList for ValuedDoubleLinkedList.LinkedList;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    modifier checkCronjob() {\n        checkCronjobs();\n        _;\n    }\n\n    /**\n     * @notice Checks if needs to execute a DAO cronJob\n     * @dev Calls executeCronjob() at the most 1 cronJob per tx\n     */\n    function checkCronjobs() public returns (bool) {\n        uint256 mostRecentCronjobTimestamp = cronjobList.getHeadValue();\n        if (mostRecentCronjobTimestamp == 0 || block.timestamp < mostRecentCronjobTimestamp) return false;\n        else {\n            // only pop head for now for gas reasons, maybe later we can execute them all together.\n            (uint256 head, uint256 timestamp) = cronjobList.popHeadAndValue();\n            executeCronjob(head, timestamp);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Executes the next DAO cronJob\n     * @param cronjobId The cronJob id to be executed.\n     * @param timestamp The current block height\n     */\n    function executeCronjob(uint256 cronjobId, uint256 timestamp) internal {\n        updateInvestment(cronjobs[cronjobId].externalId, timestamp);\n    }\n\n    /**\n     * @notice Adds a cronJob to the queue\n     * @dev Adds a node to the cronjobList (ValuedDoubleLinkedList)\n     * @param cronjobType The type of cronJob\n     * @param timestamp The current block height\n     * @param externalId Id of the request in case of dao approval, change voting request or investment\n     */\n    function addCronjob(\n        CronjobType cronjobType,\n        uint256 timestamp,\n        uint256 externalId\n    ) internal {\n        totalCronjobs = totalCronjobs.add(1);\n        cronjobs[totalCronjobs] = Cronjob(cronjobType, externalId);\n        cronjobList.addNodeIncrement(timestamp, totalCronjobs);\n    }\n\n    /**\n     * @notice Removes a cronJob from the queue\n     * @dev Removes a node from the cronjobList (ValuedDoubleLinkedList)\n     * @param cronjobId The cronJob ID\n     */\n    function removeCronjob(uint256 cronjobId) internal {\n        cronjobList.removeNode(cronjobId);\n    }\n\n    /**\n     * @notice Updates an investment\n     * @dev checks if lottery should start or adds cronJob for late application\n     * @param investmentId The id of the investment to update\n     * @param timestamp the current block height\n     */\n    function updateInvestment(uint256 investmentId, uint256 timestamp) internal {\n        if (registry.getRequestingInterestStatus(investmentId)) {\n            registry.startLotteryPhase(investmentId);\n        } else {\n            uint256 nextCronjobTimestamp =\n                timestamp.add(updatableVariables[keccak256(abi.encode(\"lateApplicationsForInvestmentDuration\"))]);\n            addCronjob(CronjobType.INVESTMENT, nextCronjobTimestamp, investmentId);\n        }\n    }\n}\n"
    },
    "contracts/governance/GovernanceTypesAndStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IRegistry.sol\";\nimport \"../libs/ValuedDoubleLinkedList.sol\";\nimport \"../libs/DoubleLinkedList.sol\";\n\n/**\n * @title AllianceBlock GovernanceStorage contract\n * @notice Responsible for governance storage\n */\ncontract GovernanceTypesAndStorage {\n    using ValuedDoubleLinkedList for ValuedDoubleLinkedList.LinkedList;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    struct ApprovalRequest {\n        uint256 investmentId; // The investment id for which approcal is requested.\n        uint256 approvalsProvided; // The number of approvals that this request has gathered.\n        bool isApproved; // True if request is approved, false if not.\n    }\n\n    // EVENTS\n    event VotedForRequest(uint256 indexed investmentId, uint256 indexed requestId, bool decision, address indexed user);\n    event ApprovalRequested(\n        uint256 indexed investmentId,\n        address indexed user\n    );\n    event InitGovernance(address indexed registryAddress_, address indexed user);\n\n    uint256 public totalApprovalRequests; // The total amount of approvals requested.\n\n    address public superDelegator;\n\n    mapping(uint256 => ApprovalRequest) public approvalRequests;\n\n    IRegistry public registry;\n\n    uint256 public totalIds;\n\n    mapping(bytes32 => uint256) public updatableVariables;\n\n    // CRONJOB types and variables\n    enum CronjobType {\n        INVESTMENT // Cronjob type for users to show interest for an investment.\n    }\n\n    struct Cronjob {\n        CronjobType cronjobType; // This is the cronjob type.\n        uint256 externalId; // This is the id of the request in case of dao approval, change voting request or investment.\n    }\n\n    // TODO - Make this simple linked list, not double (we don't need to remove anything else than head MAYBE).\n    ValuedDoubleLinkedList.LinkedList public cronjobList;\n    uint256 public totalCronjobs;\n\n    mapping(uint256 => Cronjob) public cronjobs; // cronjobId to Cronjob.\n\n    // MODIFIERS\n\n    modifier onlyRegistry() {\n        require(msg.sender == address(registry), \"Only Registry contract\");\n        _;\n    }\n}\n"
    },
    "contracts/libs/ValuedDoubleLinkedList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @title the Valued Double Linked List library\n */\nlibrary ValuedDoubleLinkedList {\n    struct Node {\n        uint256 next;\n        uint256 previous;\n        uint256 value;\n    }\n\n    struct LinkedList {\n        uint256 head;\n        uint256 tail;\n        uint256 size;\n        mapping(uint256 => Node) nodes;\n    }\n\n    /**\n     * @notice Get Head ID\n     * @param self the LinkedList\n     * @return the first item of the list\n     */\n    function getHeadId(LinkedList storage self) internal view returns (uint256) {\n        return self.head;\n    }\n\n    /**\n     * @notice Get head value\n     * @param self the LinkedList\n     * @return the value of the first node\n     */\n    function getHeadValue(LinkedList storage self) internal view returns (uint256) {\n        return self.nodes[self.head].value;\n    }\n\n    /**\n     * @notice Get list size\n     * @param self the LinkedList\n     * @return the size of the list\n     */\n    function getSize(LinkedList storage self) internal view returns (uint256) {\n        return self.size;\n    }\n\n    /**\n     * @notice Adds node increment\n     * @param self the LinkedList\n     * @param value the value to add\n     * @param id the id of the node\n     */\n    function addNodeIncrement(\n        LinkedList storage self,\n        uint256 value,\n        uint256 id\n    ) internal {\n        Node memory node = self.nodes[self.head];\n\n        //If empty\n        if (self.head == 0) {\n            self.head = id;\n            self.tail = id;\n            self.nodes[id] = Node(0, 0, value);\n        }\n        //If head\n        else if (value < node.value) {\n            self.nodes[self.head].previous = id;\n            self.nodes[id] = Node(self.head, 0, value);\n            self.head = id;\n        } else {\n            //If middle\n            if (self.size > 1) {\n                for (uint256 i = 1; i < self.size; i++) {\n                    node = self.nodes[node.next];\n                    if (value < node.value) {\n                        uint256 currentId = self.nodes[node.next].previous;\n                        self.nodes[node.next].previous = id;\n                        self.nodes[id] = Node(currentId, self.nodes[currentId].next, value);\n                        self.nodes[currentId].next = id;\n                        break;\n                    }\n                }\n            }\n            //If tail\n            if (self.nodes[id].value != value) {\n                self.nodes[id] = Node(0, self.tail, value);\n                self.nodes[self.tail].next = id;\n                self.tail = id;\n            }\n        }\n\n        self.size += 1;\n    }\n\n    /**\n     * @notice Adds node decrement\n     * @param self the LinkedList\n     * @param value the value to decrement\n     * @param id the id of the node\n     */\n    function addNodeDecrement(\n        LinkedList storage self,\n        uint256 value,\n        uint256 id\n    ) internal {\n        Node memory node = self.nodes[self.head];\n\n        //If empty\n        if (self.head == 0) {\n            self.head = id;\n            self.tail = id;\n            self.nodes[id] = Node(0, 0, value);\n        }\n        //If head\n        else if (value > node.value) {\n            self.nodes[self.head].previous = id;\n            self.nodes[id] = Node(self.head, 0, value);\n            self.head = id;\n        } else {\n            //If middle\n            if (self.size > 1) {\n                for (uint256 i = 1; i < self.size; i++) {\n                    node = self.nodes[node.next];\n                    if (value > node.value) {\n                        uint256 currentId = self.nodes[node.next].previous;\n                        self.nodes[node.next].previous = id;\n                        self.nodes[id] = Node(currentId, self.nodes[currentId].next, value);\n                        self.nodes[currentId].next = id;\n                        break;\n                    }\n                }\n            }\n            //If tail\n            if (self.nodes[id].value != value) {\n                self.nodes[id] = Node(0, self.tail, value);\n                self.nodes[self.tail].next = id;\n                self.tail = id;\n            }\n        }\n\n        self.size += 1;\n    }\n\n    /**\n     * @notice Removes a node\n     * @param self the LinkedList\n     * @param id the id of the node to remove\n     */\n    function removeNode(LinkedList storage self, uint256 id) internal {\n        if (self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        } else if (id == self.head) {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        } else if (id == self.tail) {\n            self.tail = self.nodes[self.tail].previous;\n            self.nodes[self.tail].next = 0;\n        } else {\n            self.nodes[self.nodes[id].next].previous = self.nodes[id].previous;\n            self.nodes[self.nodes[id].previous].next = self.nodes[id].next;\n        }\n\n        self.size -= 1;\n    }\n\n    /**\n     * @notice Pops the head of the list\n     * @param self the LinkedList\n     * @return head the first item of the list\n     */\n    function popHead(LinkedList storage self) internal returns (uint256 head) {\n        head = self.head;\n\n        if (self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        } else {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }\n\n        self.size -= 1;\n    }\n\n    /**\n     * @notice Pops the head and value of the list\n     * @param self the LinkedList\n     * @return head\n     * @return value\n     */\n    function popHeadAndValue(LinkedList storage self) internal returns (uint256 head, uint256 value) {\n        head = self.head;\n        value = self.nodes[self.head].value;\n\n        if (self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        } else {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }\n\n        self.size -= 1;\n    }\n\n    /**\n     * @notice Removes multiple nodes\n     * @param self the LinkedList\n     * @param amountOfNodes the number of nodes to remove starting from Head\n     */\n    function removeMultipleFromHead(LinkedList storage self, uint256 amountOfNodes) internal {\n        for (uint256 i = 0; i < amountOfNodes; i++) {\n            if (self.size == 1) {\n                self.head = 0;\n                self.tail = 0;\n            } else {\n                self.head = self.nodes[self.head].next;\n                self.nodes[self.head].previous = 0;\n            }\n\n            self.size -= 1;\n        }\n    }\n\n    /**\n     * @notice Get position from ID\n     * @param self the LinkedList\n     * @param id the id to search\n     * @return the index position for the id provided\n     */\n    function getPositionForId(LinkedList storage self, uint256 id) internal view returns (uint256) {\n        uint256 positionCounter;\n\n        if (self.nodes[id].value == 0) return 0; // If not in list.\n\n        while (true) {\n            positionCounter += 1;\n            if (id == self.head) break;\n\n            id = self.nodes[id].previous;\n        }\n\n        return positionCounter;\n    }\n\n    /**\n     * @notice Clones ValuedDoubleLinkedList\n     * @param self the LinkedList\n     * @param listToClone the LinkedList storage to clone the list from\n     */\n    function cloneList(LinkedList storage self, LinkedList storage listToClone) internal {\n        self.head = listToClone.head;\n        self.tail = listToClone.tail;\n        self.size = listToClone.size;\n\n        uint256 id = listToClone.head;\n\n        for (uint256 i = 0; i < listToClone.size; i++) {\n            self.nodes[id] = listToClone.nodes[id];\n            id = listToClone.nodes[id].next;\n        }\n    }\n}\n"
    },
    "contracts/libs/DoubleLinkedList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @title Double linked-list\n */\nlibrary DoubleLinkedList {\n    struct Node {\n        uint256 next;\n        uint256 previous;\n    }\n\n    struct LinkedList {\n        uint256 head;\n        uint256 tail;\n        uint256 size;\n        mapping(uint256 => Node) nodes;\n    }\n\n    /**\n     * @notice Get Head ID\n     * @param self the LinkedList\n     * @return the first item of the list\n     */\n    function getHeadId(LinkedList storage self) internal view returns (uint256) {\n        return self.head;\n    }\n\n    /**\n     * @notice Get list size\n     * @param self the LinkedList\n     * @return the size of the list\n     */\n    function getSize(LinkedList storage self) internal view returns (uint256) {\n        return self.size;\n    }\n\n    /**\n     * @notice Adds a new node to the list\n     * @param self the LinkedList\n     * @param id the node to add\n     */\n    function addNode(LinkedList storage self, uint256 id) internal {\n        //If empty\n        if (self.head == 0) {\n            self.head = id;\n            self.tail = id;\n            self.nodes[id] = Node(0, 0);\n        }\n        //Else push in tail\n        else {\n            self.nodes[self.tail].next = id;\n            self.nodes[id] = Node(0, self.tail);\n            self.tail = id;\n        }\n\n        self.size += 1;\n    }\n\n    /**\n     * @notice Removes node from the list\n     * @param self the LinkedList\n     * @param id the id of the node to remove\n     */\n    function removeNode(LinkedList storage self, uint256 id) internal {\n        if (self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        } else if (id == self.head) {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        } else if (id == self.tail) {\n            self.tail = self.nodes[self.tail].previous;\n            self.nodes[self.tail].next = 0;\n        } else {\n            self.nodes[self.nodes[id].next].previous = self.nodes[id].previous;\n            self.nodes[self.nodes[id].previous].next = self.nodes[id].next;\n        }\n\n        self.size -= 1;\n    }\n\n    /**\n     * @notice Pops the head of the list\n     * @param self the LinkedList\n     * @return head the first item of the list\n     */\n    function popHead(LinkedList storage self) internal returns (uint256 head) {\n        head = self.head;\n\n        if (self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        } else {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }\n\n        self.size -= 1;\n    }\n\n    /**\n     * @notice Get id by index\n     * @param self the LinkedList\n     * @param index the id of the index\n     * @return id the item in index position\n     */\n    function getIndexedId(LinkedList storage self, uint256 index) internal view returns (uint256 id) {\n        id = self.head;\n\n        for (uint256 i = 1; i < index; i++) {\n            id = self.nodes[id].next;\n        }\n    }\n\n    /**\n     * @notice Clone LinkedList\n     * @param self the LinkedList\n     * @param listToClone the LinkedList storage to clone the list from\n     */\n    function cloneList(LinkedList storage self, LinkedList storage listToClone) internal {\n        self.head = listToClone.head;\n        self.tail = listToClone.tail;\n        self.size = listToClone.size;\n\n        uint256 id = listToClone.head;\n\n        for (uint256 i = 0; i < listToClone.size; i++) {\n            self.nodes[id] = listToClone.nodes[id];\n            id = listToClone.nodes[id].next;\n        }\n    }\n}\n"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./governance/SuperGovernance.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @dev Extends Initializable, SuperGovernance\n * @notice Responsible for governing AllianceBlock's ecosystem\n */\ncontract Governance is Initializable, SuperGovernance {\n    using SafeMath for uint256;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    /**\n     * @notice Initialize the contract.\n     * @param superDelegator_ The address of the admin in charge during the first epoch\n     * @param applicationsForInvestmentDuration_ duration for applications for investment\n     * @param lateApplicationsForInvestmentDuration_ duration forlate applications for investment\n     */\n    function initialize(\n        address superDelegator_,\n        uint256 applicationsForInvestmentDuration_,\n        uint256 lateApplicationsForInvestmentDuration_\n    ) public initializer {\n        __Ownable_init();\n\n        superDelegator = superDelegator_;\n\n        updatableVariables[\n            keccak256(abi.encode(\"applicationsForInvestmentDuration\"))\n        ] = applicationsForInvestmentDuration_;\n        updatableVariables[\n            keccak256(abi.encode(\"lateApplicationsForInvestmentDuration\"))\n        ] = lateApplicationsForInvestmentDuration_;\n    }\n\n    /**\n     * @notice Update Superdelegator\n     * @dev This function is used to update the superDelegator address.\n     * @param superDelegator_ The address of the upgraded super delegator.\n     */\n    function updateSuperDelegator(address superDelegator_) external onlyOwner() {\n        superDelegator = superDelegator_;\n    }\n\n    /**\n     * @notice Request a investment or investment approval\n     * @dev Executes cronJob()\n     * @param investmentId The id of the investment or investment to approve\n     */\n    function requestApproval(\n        uint256 investmentId\n    ) external onlyRegistry() checkCronjob() {\n        approvalRequests[totalApprovalRequests].investmentId = investmentId;\n\n        emit ApprovalRequested(\n            approvalRequests[totalApprovalRequests].investmentId,\n            msg.sender\n        );\n\n        totalApprovalRequests = totalApprovalRequests.add(1);\n    }\n\n    /**\n     * @notice Stores Investment Duration\n     * @dev Adds cronJob\n     * @param investmentId The id of the investment to store\n     */\n    function storeInvestmentTriggering(uint256 investmentId) external onlyRegistry() {\n        uint256 nextCronjobTimestamp =\n            block.timestamp.add(updatableVariables[keccak256(abi.encode(\"applicationsForInvestmentDuration\"))]);\n        addCronjob(CronjobType.INVESTMENT, nextCronjobTimestamp, investmentId);\n    }\n}\n"
    },
    "contracts/governance/SuperGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./DaoCronjob.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @dev Extends OwnableUpgradeable, DaoCronjob\n * @notice Responsible for govern AllianceBlock's ecosystem\n */\ncontract SuperGovernance is OwnableUpgradeable, DaoCronjob {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Sets Registry contract\n     * @dev used to initialize SuperGovernance\n     * @dev requires not already initialized\n     * @param registryAddress_ the Registry address\n     */\n    function setRegistry(address registryAddress_) external onlyOwner() {\n        require(address(registry) == address(0), \"Cannot initialize second time\");\n        registry = IRegistry(registryAddress_);\n\n        emit InitGovernance(registryAddress_, msg.sender);\n    }\n\n    /**\n     * @notice Votes for Request\n     * @dev Executes cronJob\n     * @dev requires msg.sender to be Super Delegator\n     * @dev requires current epoch to be 0 or 1\n     * @param requestId the Request ID\n     * @param decision the decision (Approve / Deny)\n     */\n    function superVoteForRequest(uint256 requestId, bool decision) external checkCronjob() {\n        require(msg.sender == superDelegator, \"Only super delegator can call this function\");\n        require(approvalRequests[requestId].approvalsProvided == 0, \"Cannot approve again same investment\");\n\n        registry.decideForInvestment(approvalRequests[requestId].investmentId, decision);\n\n        if (decision) {\n            approvalRequests[requestId].approvalsProvided = approvalRequests[requestId].approvalsProvided.add(1);\n            approvalRequests[requestId].isApproved = true;\n        }\n\n        emit VotedForRequest(approvalRequests[requestId].investmentId, requestId, decision, msg.sender);\n    }\n}\n"
    },
    "contracts/mocks/Tests/GovernanceV2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../../Governance.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @dev WARNING Only for testing purposes, we added a couple of new methods and storage variables to check contract upgrade works fine\n * @notice Responsible for governing AllianceBlock's ecosystem\n */\ncontract GovernanceV2Test is Governance {\n    uint256 public foo;\n    uint256 public bar;\n\n    function getSomething1() public view returns (uint256) {\n        return 1;\n    }\n\n    function getSomething2() public view returns (uint256) {\n        return 2;\n    }\n}\n"
    },
    "contracts/mocks/Tests/RegistryV2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../Registry.sol\";\n\n/**\n * @title AllianceBlock Registry contract\n * @notice Responsible for loan transactions.\n */\ncontract RegistryV2Test is Registry {\n    // Only for test upgrade\n    uint256 public foo;\n    uint256 public bar;\n\n    /**\n     * @dev Only for testing purposes\n     */\n    function getSomething1() public view returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev Only for testing purposes\n     */\n    function getSomething2() public view returns (uint256) {\n        return 2;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}