{
  "language": "Solidity",
  "sources": {
    "contracts/ActionVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./libs/SignatureVerifier.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IEscrow.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\ncontract ActionVerifier is Initializable, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using SignatureVerifier for SignatureVerifier.Action;\n\n    mapping(bytes32 => uint256) public rewardPerAction;\n    uint256 public rewardPerActionProvision;\n    uint256 public maxActionsPerProvision;\n\n    IEscrow public escrow;\n\n    /**\n     * @dev Constructor of the ActionVerifier contract.\n     * @param rewardPerActionProvision_ The reward that an action provider accumulates for each action provision.\n     */\n    function initialize(\n        uint256 rewardPerActionProvision_,\n        uint256 maxActionsPerProvision_,\n        address escrow_\n    ) public initializer {\n        __Ownable_init();\n        escrow = IEscrow(escrow_);\n        rewardPerActionProvision = rewardPerActionProvision_;\n        maxActionsPerProvision = maxActionsPerProvision_;\n    }\n\n    /**\n     * @dev This function is used by the owner to add more actions.\n     * @param action The name of the action.\n     * @param reputationalAlbtReward The reputational albt reward for this action.\n     */\n    function importAction(string memory action, uint256 reputationalAlbtReward)\n        external\n        onlyOwner()\n    {\n        rewardPerAction[keccak256(abi.encodePacked(action))] = reputationalAlbtReward;\n    }\n\n    /**\n     * @dev This function is used by users to provide rewards to all users for their actions.\n     * @param actions The actions provided.\n     * @param signatures The signatures representing the actions.\n     */\n    function provideRewardsForActions(\n        SignatureVerifier.Action[] memory actions,\n        bytes[] memory signatures\n    )\n        external\n        onlyOwner()\n    {\n        require(actions.length == signatures.length, \"Invalid length\");\n        require(actions.length <= maxActionsPerProvision, \"Too many actions\");\n        // TODO - Rachid specifies the require to add here.\n\n        address[] memory accounts = new address[](actions.length.add(1));\n        uint256[] memory rewards = new uint256[](actions.length.add(1));\n\n        uint256 rewardForCaller;\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            if (\n                actions[i].isValidSignature(signatures[i]) &&\n                rewardPerAction[keccak256(abi.encodePacked(actions[i].actionName))] > 0\n            )\n            {\n                accounts[i] = actions[i].account;\n                rewards[i] = rewardPerAction[keccak256(abi.encodePacked(actions[i].actionName))];\n\n                rewardForCaller = rewardForCaller.add(rewardPerActionProvision);\n            }\n            else {\n                accounts[i] = address(0);\n                rewards[i] = 0;\n            }\n        }\n\n        accounts[actions.length] = msg.sender;\n        rewards[actions.length] = rewardForCaller;\n\n        escrow.multiMintReputationalToken(accounts, rewards);\n    }\n\n    /**\n     * @notice Check Action\n     * @dev checks if given action has a reward\n     * @return exist boolean represents checks if action has a reward associated\n    */\n    function checkAction(string memory action) public view returns (bool exist){\n         return rewardPerAction[keccak256(abi.encodePacked(action))] > 0;\n    }\n}\n"
    },
    "contracts/libs/SignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./BytesReader.sol\";\n\nlibrary SignatureVerifier {\n    using BytesReader for bytes;\n    struct EIP712Domain {\n        string  name;\n        string  version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    struct Action {\n        string actionName;\n        string answer;\n        address account;\n        uint256 referralId;\n    }\n\n    bytes32 constant ACTION_TYPEHASH = 0x1f76bf6993440811cef7b51dc00dee9d4e8fa911023c7f2d088ce4e46ac2346f;\n\n    bytes32 constant DOMAIN_SEPARATOR = 0x1dfa77e97babb94d286b16b99eb32c73720eb70b034d837f9cc6c0d2b01ba2ce;\n\n    function getActionStructHash(Action memory action) internal view returns (bytes32) {\n        return keccak256(abi.encode(\n            ACTION_TYPEHASH,\n            keccak256(bytes(action.actionName)),\n            keccak256(bytes(action.answer)),\n            action.account,\n            action.referralId\n        ));\n    }\n\n    function getActionTypedDataHash(Action memory action) internal view returns (bytes32 actionHash) {\n        actionHash = keccak256(abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR,\n            getActionStructHash(action)\n        ));\n    }\n\n    /// @dev Verifies that an action has been signed by the action.account.\n    /// @param action The action to verify the signature for.\n    /// @param signature Proof that the hash has been signed by action.account.\n    /// @return True if the address recovered from the provided signature matches the action.account.\n    function isValidSignature(\n        Action memory action,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (signature.length != 65) return false;\n\n        bytes32 hash = getActionTypedDataHash(action);\n\n        uint8 v = uint8(signature[0]);\n        bytes32 r = signature.readBytes32(1);\n        bytes32 s = signature.readBytes32(33);\n\n        address recovered = ecrecover(hash, v, r, s);\n\n        return action.account == recovered;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the Escrow.\n */\ninterface IEscrow {\n    function receiveFunding(uint256 loanId, uint256 amount) external;\n\n    function transferFundingNFT(\n        uint256 loanId,\n        uint256 partitionsToPurchase,\n        address receiver\n    ) external;\n\n    function transferLendingToken(address seeker, uint256 amount) external;\n\n    function transferCollateralToken(\n        address collateralToken,\n        address seeker,\n        uint256 amount\n    ) external;\n    function mintReputationalToken(address recipient, uint256 amount) external;\n    function burnReputationalToken(address from, uint256 amount) external;\n\n    function multiMintReputationalToken(address[] memory recipients, uint256[] memory amounts) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/libs/BytesReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nlibrary BytesReader {\n\n    /// @dev Reads a bytes32 value from a position in a byte array.\n    /// @param b Byte array containing a bytes32 value.\n    /// @param index Index in byte array of bytes32 value.\n    /// @return result bytes32 value from byte array.\n    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n        if (b.length < index + 32) {\n            return bytes32(0);\n        }\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, index))\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./staking/DaoStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Staking is Initializable, DaoStaking, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n * @dev Initialize of the contract.\n */\n    function initialize(\n        IERC20 albt_,\n        address governance_,\n        address escrow_,\n        uint256[] memory stakingTypeAmounts_,\n        uint256[] memory reputationalStakingTypeAmounts_\n    ) public initializer {\n        __Ownable_init();\n        albt = albt_;\n        governance = IGovernanceStaking(governance_);\n        escrow = IEscrow(escrow_);\n\n        // Initialize some constants\n        STAKING_DURATION = 7 days;\n        periodFinish = 0;\n        rewardRate = 0;\n\n        for(uint256 i = 0; i < stakingTypeAmounts_.length; i++) {\n            stakingTypeAmounts[i] = stakingTypeAmounts_[i];\n        }\n\n        for(uint256 i = 0; i < reputationalStakingTypeAmounts_.length; i++) {\n            reputationalStakingTypeAmounts[i] = reputationalStakingTypeAmounts_[i];\n        }\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution)\n        external\n        onlyOwner\n    {\n        rewardDistribution = _rewardDistribution;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balance[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(StakingType stakingType) public updateReward(msg.sender) {\n        require(uint256(stakingType) < 3, \"Delegator type stake only via Governance\");\n        require(balance[msg.sender] < stakingTypeAmounts[uint256(stakingType)], \"Cannot stake for same type again\");\n        uint256 amount = stakingTypeAmounts[uint256(stakingType)];\n\n        uint256 stakingTypeIndex = _getStakingType(msg.sender);\n\n        _applyReputation(msg.sender, stakingTypeIndex, uint256(stakingType).add(1));\n\n        _stake(msg.sender, amount.sub(balance[msg.sender]));\n        emit Staked(msg.sender, amount.sub(balance[msg.sender]));\n    }\n\n    // TODO - Add way to unstake only partially (drop levels)\n    function exit() external {\n        require(!freezed[msg.sender], \"Unsubscribe to exit\");\n\n        uint256 stakingTypeIndex = _getStakingType(msg.sender);\n\n        _applyReputation(msg.sender, stakingTypeIndex, 0);\n\n        _withdraw(msg.sender, balance[msg.sender]);\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            albt.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(STAKING_DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(STAKING_DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(STAKING_DURATION);\n        emit RewardAdded(reward);\n    }\n\n    function _getStakingType(address account) internal view returns (uint256) {\n        for (uint256 i = 0; i < 4; i++) {\n            if (balance[account] == stakingTypeAmounts[i]) {\n                return i.add(1);\n            }\n        }\n\n        return 0;\n    }\n\n    function _applyReputation(\n        address account,\n        uint256 previousLevelIndex,\n        uint256 newLevelIndex\n    )\n        internal\n    {\n        if (previousLevelIndex < newLevelIndex) {\n            uint256 amountToMint = findAmount(newLevelIndex, previousLevelIndex);\n            escrow.mintReputationalToken(account, amountToMint);\n        }\n        else {\n            uint256 amountToBurn = findAmount(previousLevelIndex, newLevelIndex);\n            escrow.burnReputationalToken(account, amountToBurn);\n        }\n    }\n\n    function findAmount(uint256 bigIndex, uint256 smallIndex) internal view returns (uint256 amount) {\n        if (bigIndex > 3) bigIndex = 3;\n        if (smallIndex == 0) {\n            amount = reputationalStakingTypeAmounts[bigIndex.sub(1)];\n        }\n        else {\n            amount = reputationalStakingTypeAmounts[bigIndex.sub(1)].sub(\n                reputationalStakingTypeAmounts[smallIndex.sub(1)]);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/staking/DaoStaking.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./StakingTypesAndStorage.sol\";\nimport \"hardhat/console.sol\";\n\ncontract DaoStaking is StakingTypesAndStorage {\n    using SafeMath for uint256;\n\n    function provideStakingForDaoMembership(address staker) external onlyGovernance() {\n        uint256 amount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_3_OR_DAO_MEMBER)].sub(balance[staker]);\n\n        freezed[staker] = true;\n\n        _stake(staker, amount);\n    }\n\n    function provideStakingForDaoDelegator(address staker) external onlyGovernance() {\n        require(balance[staker] == stakingTypeAmounts[uint256(StakingType.STAKER_LVL_3_OR_DAO_MEMBER)],\n            \"Must be already a dao member subscriber\");\n\n        uint256 amount = stakingTypeAmounts[uint256(StakingType.DAO_DELEGATOR)].sub(\n            stakingTypeAmounts[uint256(StakingType.STAKER_LVL_3_OR_DAO_MEMBER)]);\n\n        _stake(staker, amount);\n    }\n\n    function unstakeDao(address staker, bool isDaoMember) external onlyGovernance() {\n        freezed[staker] = false;\n\n        if (!isDaoMember) _unstakeDaoDelegator(staker);\n    }\n\n    function provideRewards(\n        uint256 amountForDaoMembers,\n        uint256 amountForDaoDelegators,\n        uint256 epoch\n    )\n    external\n    onlyGovernance()\n    {\n        rewardsPerEpochForDaoMembers[epoch] = amountForDaoMembers;\n        rewardsPerEpochForDaoDelegators[epoch] = amountForDaoDelegators;\n\n        currentEpoch = epoch.add(1);\n    }\n\n    function withdrawRewardsForDaoEpoch(uint256 epoch) external {\n        require(epoch < currentEpoch, \"Can withdraw only for previous epoch\");\n\n        (bool isDaoMember, bool isDaoDelegator, uint256 amountOfDaoMembers, uint256 amountOfDaoDelegators) =\n            governance.isDaoAssociated(msg.sender, epoch);\n        require(isDaoMember || isDaoDelegator, \"Should be part of the dao\");\n\n        require(!hasWithdrawn[msg.sender], \"Already withdrawn\");\n        hasWithdrawn[msg.sender] = true;\n\n        uint256 amountToWithdraw;\n\n        if(isDaoMember) {\n            amountToWithdraw = rewardsPerEpochForDaoMembers[epoch].div(amountOfDaoMembers);\n        } else {\n            amountToWithdraw = rewardsPerEpochForDaoDelegators[epoch].div(amountOfDaoDelegators);\n        }\n\n        _withdraw(msg.sender, amountToWithdraw);\n    }\n\n    function _unstakeDaoDelegator(address staker_) internal {\n        uint256 amount = stakingTypeAmounts[uint256(StakingType.DAO_DELEGATOR)].sub(\n            stakingTypeAmounts[uint256(StakingType.STAKER_LVL_3_OR_DAO_MEMBER)]);\n\n        _withdraw(staker_, amount);\n    }\n\n    function _withdraw(address staker_, uint256 amount_) internal {\n        totalSupply = totalSupply.sub(amount_);\n        balance[staker_] = balance[staker_].sub(amount_);\n        albt.transfer(staker_, amount_);\n    }\n\n    function _stake(address staker_, uint256 amount_) internal {\n        albt.transferFrom(staker_, address(this), amount_);\n        totalSupply = totalSupply.add(amount_);\n        balance[staker_] = balance[staker_].add(amount_);\n    }\n\n    function getBalance(address staker_) external view returns (uint256) {\n        return balance[staker_];\n    }\n\n    function getAmountsToStake() external view returns (\n        uint256 stakerLvl1Amount,\n        uint256 stakerLvl2Amount,\n        uint256 stakerLvl3orDaoMemberAmount,\n        uint256 daoDelegatorAmount\n    ) {\n        stakerLvl1Amount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_1)];\n        stakerLvl2Amount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_2)];\n        stakerLvl3orDaoMemberAmount = stakingTypeAmounts[uint256(StakingType.STAKER_LVL_3_OR_DAO_MEMBER)];\n        daoDelegatorAmount = stakingTypeAmounts[uint256(StakingType.DAO_DELEGATOR)];\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/StakingTypesAndStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IGovernanceStaking.sol\";\nimport \"../interfaces/IEscrow.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title AllianceBlock StakingStorage contract\n * @notice Responsible for staking storage\n */\ncontract StakingTypesAndStorage {\n    enum StakingType {\n        STAKER_LVL_1,\n        STAKER_LVL_2,\n        STAKER_LVL_3_OR_DAO_MEMBER,\n        DAO_DELEGATOR\n    }\n\n    uint256 public STAKING_DURATION;\n\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    mapping(uint256 => uint256) public rewardsPerEpochForDaoMembers;\n    mapping(uint256 => uint256) public rewardsPerEpochForDaoDelegators;\n    mapping(address => bool) public hasWithdrawn;\n\n    // ALBT token\n    IERC20 public albt;\n\n    IGovernanceStaking public governance;\n    IEscrow public escrow;\n    address public rewardDistribution;\n\n    uint256 public totalSupply;\n    uint256 public currentEpoch;\n    mapping(address => uint256) public balance;\n    mapping(address => bool) public freezed;\n    mapping(uint256 => uint256) public stakingTypeAmounts; // Amounts required for each staking type.\n    mapping(uint256 => uint256) public reputationalStakingTypeAmounts; // Amounts of rALBT provided for each staking type.\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier onlyRewardDistribution() {\n        require(msg.sender == rewardDistribution, \"Caller is not reward distribution\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == address(governance), \"Caller can only be governance\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IGovernanceStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the Governance contract used by staking contract.\n */\ninterface IGovernanceStaking {\n    function isDaoAssociated(address account, uint256 epoch) external view returns(bool, bool, uint256, uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../token/ERC20/ERC20.sol\";\nimport \"../token/ERC20/ERC20Burnable.sol\";\nimport \"../token/ERC20/ERC20Pausable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControl, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/mocks/ProjectToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n */\ncontract ProjectToken is ERC20PresetMinterPauser {\n    constructor() ERC20PresetMinterPauser(\"Project Token\", \"PT\"){}\n}\n"
    },
    "contracts/mocks/LendingToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n */\ncontract LendingToken is ERC20PresetMinterPauser {\n    constructor() ERC20PresetMinterPauser(\"Lending Token\", \"LGT\"){}\n}\n"
    },
    "contracts/mocks/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n */\ncontract CollateralToken is ERC20PresetMinterPauser {\n    constructor() public ERC20PresetMinterPauser(\"Collateral Token\", \"CLT\"){}\n}\n"
    },
    "contracts/mocks/ALBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n/**\n * @title Mock contract for ALBT ERC20 Token\n */\ncontract ALBT is ERC20PresetMinterPauser {\n    constructor() public ERC20PresetMinterPauser(\"AllianceBlock Token\", \"ALBT\"){}\n}\n"
    },
    "contracts/registry/Investment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./LoanDetails.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title AllianceBlock Investment contract\n * @notice Functionality for Investment.\n */\ncontract Investment is LoanDetails {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    // TODO - EVENTS\n\n    /**\n     * @dev This function is used for projects to request investment in exchange for project tokens.\n     * @param investmentToken The token that will be purchased by investors.\n     * @param amountOfInvestmentTokens The amount of investment tokens to be purchased.\n     * @param totalAmountRequested_ The total amount requested so as all investment tokens to be sold.\n     * @param extraInfo The ipfs hash where more specific details for loan request are stored.\n     */\n    function requestInvestment(\n        address investmentToken,\n        uint256 amountOfInvestmentTokens,\n        uint256 totalAmountRequested_,\n        string memory extraInfo\n    ) external {\n        // TODO - Change 10 ** 18 to decimals if needed.\n        require(\n            totalAmountRequested_.mod(baseAmountForEachPartition) == 0 &&\n            totalAmountRequested_.mul(10**18).mod(amountOfInvestmentTokens) == 0,\n            \"Token amount and price should result in integer amount of tickets\"\n        );\n\n        _storeLoanDetails(\n            LoanLibrary.LoanType.INVESTMENT,\n            totalAmountRequested_,\n            investmentToken,\n            amountOfInvestmentTokens,\n            0,\n            extraInfo\n        );\n\n        IERC20(investmentToken).transferFrom(\n            msg.sender,\n            address(escrow),\n            amountOfInvestmentTokens\n        );\n\n        fundingNFT.mintGen0(\n            address(escrow),\n            loanDetails[totalLoans].totalPartitions,\n            totalLoans\n        );\n\n        investmentTokensPerTicket[totalLoans] = amountOfInvestmentTokens.div(\n            loanDetails[totalLoans].totalPartitions);\n\n        fundingNFT.pauseTokenTransfer(totalLoans); //Pause trades for ERC1155s with the specific loan ID.\n\n        governance.requestApproval(totalLoans, false, 0);\n\n        // Add event for investment request\n\n        totalLoans = totalLoans.add(1);\n    }\n\n    /**\n     * @dev This function is called by the investors who are interested to invest in a specific project.\n     * @param investmentId The id of the investment.\n     * @param amountOfPartitions The amount of partitions this specific investor wanna invest in.\n     */\n    function showInterestForInvestment(uint256 investmentId, uint256 amountOfPartitions)\n        external\n    {\n        require(loanStatus[investmentId] == LoanLibrary.LoanStatus.APPROVED, \"Can show interest only in Approved state\");\n        require(amountOfPartitions > 0, \"Cannot show interest for 0 partitions\");\n\n        lendingToken.transferFrom(\n            msg.sender,\n            address(escrow),\n            amountOfPartitions.mul(baseAmountForEachPartition)\n        );\n\n        loanDetails[investmentId].partitionsPurchased = loanDetails[investmentId].partitionsPurchased.add(amountOfPartitions);\n\n        uint256 reputationalBalance = _updateReputationalBalanceForPreviouslyLockedTokens();\n        uint256 totalLotteryNumbers = reputationalBalance.div(rAlbtPerLotteryNumber);\n\n        if (totalLotteryNumbers == 0) return; // Maybe revert here?\n\n        uint256 immediateTickets;\n\n        // TODO - Explain this check to Rachid.\n        while (totalLotteryNumbers > lotteryNumbersForImmediateTicket) {\n            immediateTickets = immediateTickets.add(1);\n            totalLotteryNumbers = totalLotteryNumbers.sub(lotteryNumbersForImmediateTicket);\n        }\n\n        if (immediateTickets > amountOfPartitions) immediateTickets = amountOfPartitions;\n\n        // Just in case we provided immediate tickets and tickets finished, so there is no lottery in this case.\n        if (immediateTickets > ticketsRemaining[investmentId]) {\n            immediateTickets = ticketsRemaining[investmentId];\n            loanStatus[investmentId] = LoanLibrary.LoanStatus.SETTLED;\n\n            // Maybe also stop the procedure here.\n        }\n\n        if (immediateTickets > 0) {\n            ticketsWonPerAddress[investmentId][msg.sender] = immediateTickets;\n            ticketsRemaining[investmentId] = ticketsRemaining[investmentId].sub(immediateTickets);\n        }\n\n        remainingTicketsPerAddress[investmentId][msg.sender] = amountOfPartitions.sub(immediateTickets);\n\n        uint256 maxLotteryNumber = totalLotteryNumbersPerInvestment[investmentId].add(totalLotteryNumbers);\n\n        for (uint256 i = totalLotteryNumbersPerInvestment[investmentId].add(1); i <= maxLotteryNumber; i++) {\n            addressOfLotteryNumber[investmentId][i] = msg.sender;\n        }\n\n        totalLotteryNumbersPerInvestment[investmentId] = maxLotteryNumber;\n    }\n\n    /**\n     * @dev This function is called by any investor interested in a project to run part of the lottery.\n     * @param investmentId The id of the investment.\n     */\n    function executeLotteryRun(uint256 investmentId)\n        external\n    {\n        require(loanStatus[investmentId] == LoanLibrary.LoanStatus.STARTED, \"Can run lottery only in Started state\");\n        require(remainingTicketsPerAddress[investmentId][msg.sender] > 0, \"Can run lottery only if has remaining ticket\");\n\n        ticketsWonPerAddress[investmentId][msg.sender] = ticketsWonPerAddress[investmentId][msg.sender].add(1);\n        remainingTicketsPerAddress[investmentId][msg.sender] = remainingTicketsPerAddress[investmentId][msg.sender].sub(1);\n        ticketsRemaining[investmentId] = ticketsRemaining[investmentId].sub(1);\n\n        uint256 counter = totalTicketsPerRun;\n        uint256 maxNumber = totalLotteryNumbersPerInvestment[investmentId];\n\n        if (ticketsRemaining[investmentId] <= counter) {\n            loanStatus[investmentId] = LoanLibrary.LoanStatus.SETTLED;\n            counter = ticketsRemaining[investmentId];\n            ticketsRemaining[investmentId] = 0;\n        } else {\n            ticketsRemaining[investmentId] = ticketsRemaining[investmentId].sub(counter);\n        }\n\n        while (counter != 0) {\n            uint256 randomNumber = getRandomNumber(maxNumber);\n            lotteryNonce = lotteryNonce.add(1);\n\n            address randomAddress = addressOfLotteryNumber[investmentId][randomNumber.add(1)];\n\n            if (remainingTicketsPerAddress[investmentId][randomAddress] > 0) {\n                remainingTicketsPerAddress[investmentId][randomAddress] =\n                    remainingTicketsPerAddress[investmentId][randomAddress].sub(1);\n\n                ticketsWonPerAddress[investmentId][randomAddress] =\n                    ticketsWonPerAddress[investmentId][randomAddress].add(1);\n\n                counter -= 1;\n            }\n        }\n    }\n\n    /**\n     * @dev This function is called by an investor to withdraw his tickets.\n     * @param investmentId The id of the investment.\n     * @param ticketsToLock The amount of won tickets to be locked, so as to get more rALBT.\n     * @param ticketsToWithdraw The amount of won tickets to be withdrawn instantly.\n     */\n    function withdrawInvestmentTickets(uint256 investmentId, uint256 ticketsToLock, uint256 ticketsToWithdraw)\n        external\n    {\n        require(loanStatus[investmentId] == LoanLibrary.LoanStatus.SETTLED, \"Can withdraw only in Settled state\");\n        require(ticketsWonPerAddress[investmentId][msg.sender] > 0 &&\n            ticketsWonPerAddress[investmentId][msg.sender] >= ticketsToLock.add(ticketsToWithdraw),\n            \"Not enough tickets won\"\n        );\n\n        ticketsWonPerAddress[investmentId][msg.sender] = ticketsWonPerAddress[investmentId][msg.sender].sub(\n            ticketsToLock).sub(ticketsToWithdraw);\n\n        _updateReputationalBalanceForPreviouslyLockedTokens();\n\n        if (ticketsToLock > 0) {\n            lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender] =\n                lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender].add(ticketsToLock);\n\n            lockedTicketsPerAddress[msg.sender] = lockedTicketsPerAddress[msg.sender].add(ticketsToLock);\n        }\n\n        if (ticketsToWithdraw > 0) {\n            uint256 amountToWithdraw = investmentTokensPerTicket[investmentId].mul(ticketsToWithdraw);\n            escrow.transferCollateralToken(loanDetails[investmentId].collateralToken ,msg.sender, amountToWithdraw);\n        }\n\n        if (remainingTicketsPerAddress[investmentId][msg.sender] > 0) {\n            _withdrawAmountProvidedForNonWonTickets(investmentId);\n        }\n    }\n\n    /**\n     * @dev This function is called by an investor to withdraw lending tokens provided for non-won tickets.\n     * @param investmentId The id of the investment.\n     */\n    function withdrawAmountProvidedForNonWonTickets(uint256 investmentId)\n        external\n    {\n        require(loanStatus[investmentId] == LoanLibrary.LoanStatus.SETTLED, \"Can withdraw only in Settled state\");\n        require(remainingTicketsPerAddress[investmentId][msg.sender] > 0, \"No non-won tickets to withdraw\");\n\n        _withdrawAmountProvidedForNonWonTickets(investmentId);\n    }\n\n    /**\n     * @dev This function is called by an investor to withdraw his locked tickets.\n     * @param investmentId The id of the investment.\n     * @param ticketsToWithdraw The amount of locked tickets to be withdrawn.\n     */\n    function withdrawLockedInvestmentTickets(uint256 investmentId, uint256 ticketsToWithdraw)\n        external\n    {\n        require(loanStatus[investmentId] == LoanLibrary.LoanStatus.SETTLED, \"Can withdraw only in Settled state\");\n        require(ticketsToWithdraw > 0 &&\n            lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender] >= ticketsToWithdraw,\n            \"Not enough tickets to withdraw\"\n        );\n\n        _updateReputationalBalanceForPreviouslyLockedTokens();\n\n        lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender] =\n            lockedTicketsForSpecificInvestmentPerAddress[investmentId][msg.sender].sub(ticketsToWithdraw);\n\n        lockedTicketsPerAddress[msg.sender] = lockedTicketsPerAddress[msg.sender].sub(ticketsToWithdraw);\n\n        uint256 amountToWithdraw = investmentTokensPerTicket[investmentId].mul(ticketsToWithdraw);\n        escrow.transferCollateralToken(loanDetails[investmentId].collateralToken, msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @dev This function returns true if investors have shown interest for equal or more than the total\n     *      tickets.\n     * @param investmentId The id of the investment type to be checked.\n     */\n    function getRequestingInterestStatus(uint256 investmentId) external view returns (bool) {\n        return loanDetails[investmentId].totalPartitions <= loanDetails[investmentId].partitionsPurchased;\n    }\n\n    function getRandomNumber(uint256 maxNumber) internal view returns (uint256 randomNumber) {\n        randomNumber = uint256(keccak256(abi.encodePacked(\n                block.difficulty,\n                block.timestamp,\n                lotteryNonce,\n                blockhash(block.number),\n                msg.sender\n            ))).mod(maxNumber);\n    }\n\n    function _updateReputationalBalanceForPreviouslyLockedTokens() internal returns (uint256) {\n        if (lockedTicketsPerAddress[msg.sender] > 0) {\n            uint256 amountOfReputationalAlbtPerTicket = (block.number.sub(\n                lastBlockCheckedForLockedTicketsPerAddress[msg.sender])).div(blocksLockedForReputation);\n\n            uint256 amountOfReputationalAlbtToMint = amountOfReputationalAlbtPerTicket.mul(\n                lockedTicketsPerAddress[msg.sender]);\n\n            if (amountOfReputationalAlbtToMint > 0)\n                escrow.mintReputationalToken(msg.sender, amountOfReputationalAlbtToMint);\n\n            lastBlockCheckedForLockedTicketsPerAddress[msg.sender] = block.number;\n        }\n\n        return rALBT.balanceOf(msg.sender);\n    }\n\n    function _withdrawAmountProvidedForNonWonTickets(uint256 investmentId_)\n        internal\n    {\n        uint256 amountToReturnForNonWonTickets = remainingTicketsPerAddress[investmentId_][msg.sender].mul(\n            baseAmountForEachPartition);\n        remainingTicketsPerAddress[investmentId_][msg.sender] = 0;\n\n        escrow.transferLendingToken(msg.sender, amountToReturnForNonWonTickets);\n    }\n}\n"
    },
    "contracts/registry/LoanDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Storage.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title AllianceBlock LoanDetails contract\n * @notice Functionality for storing loan details and modifiers.\n */\ncontract LoanDetails is Storage {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    modifier onlyGovernance() {\n        require(msg.sender == address(governance), \"Only Governance\");\n        _;\n    }\n\n    modifier onlySeeker(uint256 loanId) {\n        require(\n            msg.sender == loanSeeker[loanId],\n            \"Only seeker of the loan\"\n        );\n        _;\n    }\n\n    modifier onlyActivelyFundedLoan(uint256 loanId) {\n        require(\n            loanStatus[loanId] == LoanLibrary.LoanStatus.APPROVED ||\n                loanStatus[loanId] == LoanLibrary.LoanStatus.FUNDING,\n            \"Only when loan is actively getting funded\"\n        );\n        require(\n            loanDetails[loanId].approvalDate.add(fundingTimeInterval) >\n                block.timestamp,\n            \"Only between funding timeframe\"\n        );\n        _;\n    }\n\n    modifier onlyActiveLoan(uint256 loanId) {\n        require(\n            loanStatus[loanId] == LoanLibrary.LoanStatus.STARTED ||\n                loanStatus[loanId] ==\n                LoanLibrary.LoanStatus.AWAITING_MILESTONE_APPLICATION,\n            \"Only when loan is active\"\n        );\n        _;\n    }\n\n    modifier onlyOnProjectRepayment(uint256 loanId) {\n        require(\n            loanStatus[loanId] == LoanLibrary.LoanStatus.AWAITING_REPAYMENT,\n            \"Only on Repayment Status\"\n        );\n        require(\n            projectLoanPayments[loanId].awaitingForRepaymentDate.add(\n                projectLoanPayments[loanId].paymentTimeInterval\n            ) > block.timestamp,\n            \"Only between awaiting for repayment timeframe\"\n        );\n        _;\n    }\n\n    modifier onlySettledLoan(uint256 loanId) {\n        require(\n            loanStatus[loanId] == LoanLibrary.LoanStatus.SETTLED,\n            \"Only on Settled Status\"\n        );\n        _;\n    }\n\n    modifier onlyBetweenMilestoneTimeframe(uint256 loanId) {\n        require(\n            projectLoanPayments[loanId].currentMilestoneDeadlineTimestamp >\n                block.timestamp &&\n                projectLoanPayments[loanId].currentMilestoneStartingTimestamp <=\n                block.timestamp,\n            \"Only between milestone's timeframe\"\n        );\n        _;\n    }\n\n    modifier onlyBetweenBatchTimeframe(uint256 loanId) {\n        require(\n            personalLoanPayments[loanId].batchDeadlineTimestamp >\n                block.timestamp &&\n                personalLoanPayments[loanId].batchStartingTimestamp <=\n                block.timestamp,\n            \"Only between batch timeframe\"\n        );\n        _;\n    }\n\n    modifier onlyAfterDeadlineReached(uint256 loanId) {\n        if (loanDetails[loanId].loanType == LoanLibrary.LoanType.PERSONAL) {\n            require(\n                personalLoanPayments[loanId].batchDeadlineTimestamp <=\n                    block.timestamp,\n                \"Only after batch deadline is reached\"\n            );\n        } else {\n            require(\n                projectLoanPayments[loanId].currentMilestoneDeadlineTimestamp <=\n                    block.timestamp,\n                \"Only after milestone deadline is reached\"\n            );\n        }\n        _;\n    }\n\n    modifier onlyPersonalLoan(uint256 loanId) {\n        require(\n            loanDetails[loanId].loanType == LoanLibrary.LoanType.PERSONAL,\n            \"Only when loan is personal\"\n        );\n        _;\n    }\n\n    modifier onlyProjectLoan(uint256 loanId) {\n        require(\n            loanDetails[loanId].loanType == LoanLibrary.LoanType.PROJECT,\n            \"Only when loan is for project\"\n        );\n        _;\n    }\n\n    modifier onlyAcceptedNumberOfMilestones(uint256 totalMilestones) {\n        require(\n            totalMilestones <= maxMilestones,\n            \"Only accepted number of milestones\"\n        );\n        _;\n    }\n\n    modifier onlyWhenAwaitingMilestoneApproval(uint256 loanId) {\n        require(\n            loanStatus[loanId] ==\n                LoanLibrary.LoanStatus.AWAITING_MILESTONE_APPROVAL,\n            \"Only when loan is awaiting for milestone approval\"\n        );\n        _;\n    }\n\n    modifier onlyEnoughERC1155Balance(uint256 loanId, uint256 amountOfTokens) {\n        uint256 balance;\n        for (\n            uint256 i = 0;\n            i < projectLoanPayments[loanId].totalMilestones;\n            i++\n        ) {\n            balance = balance.add(\n                fundingNFT.balanceOf(msg.sender, i.getTokenId(loanId))\n            );\n        }\n        require(balance >= amountOfTokens, \"Only when enough balance\");\n        _;\n    }\n\n    function _storeLoanDetails(\n        LoanLibrary.LoanType loanType_,\n        uint256 lendingAmountRequested_,\n        address collateralToken_,\n        uint256 collateralAmount_,\n        uint256 interestPercentage_,\n        string memory extraInfo_\n    ) internal {\n        require(\n            interestPercentage_ >= minimumInterestPercentage,\n            \"Interest percentage lower than limit\"\n        );\n\n        LoanLibrary.LoanDetails memory loan;\n        loan.loanId = totalLoans;\n        loan.loanType = loanType_;\n        loan.collateralToken = collateralToken_;\n        loan.collateralAmount = collateralAmount_;\n        loan.lendingAmount = lendingAmountRequested_;\n        loan.interestPercentage = interestPercentage_;\n        loan.totalInterest = lendingAmountRequested_\n            .mul(interestPercentage_)\n            .div(100);\n        loan.extraInfo = extraInfo_;\n        loan.totalPartitions = lendingAmountRequested_.div(\n            baseAmountForEachPartition\n        );\n\n        loanDetails[totalLoans] = loan;\n\n        loanStatus[totalLoans] = LoanLibrary.LoanStatus.REQUESTED;\n        loanSeeker[totalLoans] = msg.sender;\n    }\n}\n"
    },
    "contracts/libs/TokenFormat.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.0;\n\nlibrary TokenFormat {\n    // Use a split bit implementation.\n    // Store the generation in the upper 128 bits..\n    // ..and the non-fungible loan id in the lower 128\n    uint256 private constant _LOAN_ID_MASK = uint128(~0);\n\n    /**\n     * @dev Format tokenId into generation and index\n     */\n    function formatTokenId(uint tokenId) internal pure returns(uint generation, uint loanId) {\n        generation = tokenId >> 128;\n        loanId = tokenId & _LOAN_ID_MASK;\n    }\n\n    /**\n     * @dev get tokenId from generation and loanId\n     */\n    function getTokenId(uint gen, uint loanId) internal pure returns(uint tokenId) {\n        return (gen << 128) | loanId;\n    }\n}\n"
    },
    "contracts/registry/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libs/LoanLibrary.sol\";\nimport \"../interfaces/IERC1155Mint.sol\";\nimport \"../interfaces/IERC721Mint.sol\";\nimport \"../interfaces/IGovernance.sol\";\nimport \"../interfaces/IEscrow.sol\";\n\n/**\n * @title AllianceBlock Storage contract\n * @notice Responsible for loan storage\n */\ncontract Storage {\n    uint256 public totalLoans; // The total amount of loan requests.\n\n    // Mapping from loan id -> details for each and every loan.\n    mapping(uint256 => LoanLibrary.LoanDetails) public loanDetails;\n    // Mapping from loan id -> details for personal loans.\n    mapping(uint256 => LoanLibrary.PersonalLoanPayments) public personalLoanPayments;\n    // Mapping from loan id -> details for project loans.\n    mapping(uint256 => LoanLibrary.ProjectLoanPayments) public projectLoanPayments;\n    // Mapping from loan id -> loan status.\n    mapping(uint256 => LoanLibrary.LoanStatus) public loanStatus;\n    // Mapping from loan id -> loan seeker's address.\n    mapping(uint256 => address) public loanSeeker;\n    // The amount of investment tokens each ticket contains. (Only for INVESTMENT type)\n    mapping(uint256 => uint256) public investmentTokensPerTicket;\n    // The amount of tickets remaining to be allocated to investors. (Only for INVESTMENT type)\n    mapping(uint256 => uint256) public ticketsRemaining;\n    // The number lottery numbers allocated from all investors for a specific investment.\n    mapping(uint256 => uint256) public totalLotteryNumbersPerInvestment;\n    // The address of the investor that has allocated a specific lottery number on a specific investment.\n    mapping(uint256 => mapping(uint256 => address)) public addressOfLotteryNumber;\n    // The amount of tickets that an investor requested that are still not allocated.\n    mapping(uint256 => mapping(address => uint256)) public remainingTicketsPerAddress;\n    // The amount of tickets that an investor requested that have been won already.\n    mapping(uint256 => mapping(address => uint256)) public ticketsWonPerAddress;\n    // The amount of tickets that an investor locked for a specific investment.\n    mapping(uint256 => mapping(address => uint256)) public lockedTicketsForSpecificInvestmentPerAddress;\n    // The amount of tickets that an investor locked from all investments.\n    mapping(address => uint256) public lockedTicketsPerAddress;\n    // The last block checked for rewards for the tickets locked per address.\n    mapping(address => uint256) public lastBlockCheckedForLockedTicketsPerAddress;\n\n    IGovernance public governance; // Governance's contract address.\n    IERC20 public lendingToken; // Lending token's contract address.\n    IERC721Mint public mainNFT; // Main nft's contract address.\n    IERC1155Mint public fundingNFT; // Funding nft's contract address.\n    IEscrow public escrow; // Escrow's contract address.\n    IERC20 public rALBT; // rALBT's contract address.\n\n    // This variable represents the base amount in which every loan amount is divided to. (also the starting value for each ERC1155)\n    uint256 public baseAmountForEachPartition;\n    // This variable represents the minimum interest percentage that each loan should have.\n    uint256 public minimumInterestPercentage;\n    // This variable represents the maximum number of milestones a project loan can contain.\n    uint256 public maxMilestones;\n    // If milestone is rejected, this time interval is provided for the project to deliver.\n    uint256 public milestoneExtensionInterval;\n    // The amount of vesting batches when a lender decides to get project tokens.\n    uint256 public vestingBatches;\n    // The time interval between vesting batches when a lender decides to get project tokens.\n    uint256 public vestingTimeInterval;\n    // The time interval for adding funds.\n    uint256 public fundingTimeInterval;\n    // The amount of tickets to be provided by each run of the lottery.\n    uint256 public totalTicketsPerRun;\n    // The amount of rALBT needed to allocate one lottery number.\n    uint256 public rAlbtPerLotteryNumber;\n    // The amount of blocks needed for a ticket to be locked, so as the investor to get 1 rALBT.\n    uint256 public blocksLockedForReputation;\n    // The amount of lottery numbers, that if investor has after number allocation he gets one ticket without lottery.\n    uint256 public lotteryNumbersForImmediateTicket;\n    // The nonce for the lottery numbers.\n    uint256 internal lotteryNonce;\n}\n"
    },
    "contracts/libs/LoanLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.0;\n\nlibrary LoanLibrary {\n    enum RepaymentBatchType {\n        ONLY_INTEREST, // The interest is repaid in each batch and at the last batch nominal is also repaid.\n        INTEREST_PLUS_NOMINAL // In every batch part of nominal alongside interest is getting repaid.\n    }\n\n    enum LoanType {\n        PERSONAL, // The type of loan where seeker is a person.\n        PROJECT, // The type of loan where seeker is a project.\n        INVESTMENT // The type of loan where seeker is a project seeking for IDO.\n    }\n\n    enum LoanStatus {\n        REQUESTED, // Status when loan has been requested, but not approved yet.\n        APPROVED, // Status when loan has been approved from governors.\n        FUNDING, // Status when loan has started getting funded, but not fully funded yet.\n        STARTED, // Status when loan has been fully funded.\n        AWAITING_MILESTONE_APPROVAL, // Status when loan is waiting for DAO to approve a finished milestone.\n        AWAITING_REPAYMENT, // Status when milestones have all been delivered and waiting for repayment from the project.\n        SETTLED, // Status when loan has been fully repaid by the seeker.\n        DEFAULT, // Status when seeker has not been able to repay the loan.\n        LIQUIDATED, // Status when collateral's value was not enough, so loan got liquidated.\n        REJECTED, // Status when loan has been rejected by governors.\n        // TEMPORAL: waiting for status order and to not break test\n        AWAITING_MILESTONE_APPLICATION // Status when loan is waiting for milestone application by the project.\n    }\n\n    struct LoanDetails {\n        uint256 loanId; // The Id of the loan.\n        LoanType loanType; // The type of the loan (personal or project).\n        uint256 approvalDate; // The timestamp in which loan was approved.\n        uint256 startingDate; // The timestamp in which loan was funded.\n        address collateralToken; // The address of the token that was put as collateral for the loan.\n        uint256 collateralAmount; // The amount of collateral tokens locked as colateral.\n        uint256 lendingAmount; // The amount of tokens that was lended to the seeker.\n        uint256 totalPartitions; // The total partitions or ERC1155 tokens, in which loan is splitted.\n        uint256 totalInterest; // The amount of interest to be paid.\n        uint256 interestPercentage; // The interest percentage to pay back over the amount in lending tokens.\n        string extraInfo; // The ipfs hash, where all extra info about the loan are stored.\n        uint256 partitionsPurchased; // The total partitions or ERC1155 tokens that have already been purchased.\n    }\n\n    struct PersonalLoanPayments {\n        uint256 batchesPaid; // The amount of batches that have been paid by the seeker.\n        uint256 amountEachBatch; // The amount to be paid in each batch by the seeker.\n        uint256 totalAmountOfBatches; // The total amount of batches for the loan repayment.\n        uint256 timeIntervalBetweenBatches; // The time interval, which represents how often seeker should pay a batch.\n        uint256 batchesSkipped; // The times that seeker skipped the payment (only 1 is accepted, then loan gets to DEFAULT).\n        uint256 batchStartingTimestamp; // Timestamp from which seeker is able to pay next batch.\n        uint256 batchDeadlineTimestamp; // Timestamp till which seeker should pay next batch.\n        RepaymentBatchType repaymentBatchType; // The repayment batch type of the loan.\n    }\n\n    struct ProjectLoanPayments {\n        uint256 totalMilestones;\n        mapping(uint256 => uint256) milestoneLendingAmount;\n        mapping(uint256 => uint256) milestoneDuration;\n        uint256 awaitingForRepaymentDate; // The timestamp in which loan state changed to awaitingForRepayment.\n        uint256 paymentTimeInterval; // The time interval that will pass between last milestone delivery and repayment.\n        uint256 milestonesDelivered; // The amount of milestones that have been delivered by the project.\n        uint256 milestonesExtended; // The times that project has taken an extension for milestone delivery.\n        uint256 currentMilestoneStartingTimestamp; // Timestamp that milestone/repayment started.\n        uint256 currentMilestoneDeadlineTimestamp; // Timestamp that milestone/repayment should be delivered.\n        uint256 discountPerMillion; // The discount / 1M if lenders decide to get paid by the project tokens.\n        mapping(uint256 => uint256) milestoneProjectTokenPrice; // The price the project tokens can be claimed for after delivery of the milestone.\n        uint256 partitionsPaidInProjectTokens; // The number of partitions lenders used to claim project tokens.\n    }\n}\n"
    },
    "contracts/interfaces/IERC1155Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the IERC1155 mint function.\n */\ninterface IERC1155Mint {\n    function mintGen0(address to, uint256 amount, uint256 loanId) external;\n\n    function mintOfGen(\n        address to,\n        uint256 amount,\n        uint256 generation,\n        uint256 loanId\n    ) external;\n\n    function decreaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToDecrease\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function pauseTokenTransfer(uint256 loanId) external;\n\n    function unpauseTokenTransfer(uint256 tokenId) external;\n\n    function increaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToAdd\n    ) external;\n\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IERC721Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the IERC721 mint function.\n */\ninterface IERC721Mint {\n    function mint(address to) external virtual;\n}\n"
    },
    "contracts/interfaces/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the Governance contract.\n */\ninterface IGovernance {\n    function requestApproval(uint256 loanId, bool isMilestone, uint256 milestoneNumber) external;\n    function storeInvestmentTriggering(uint256 loanId) external;\n}\n"
    },
    "contracts/NFTs/FundingNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title Alliance Block Funding NFTs\n * @notice NFTs that will be held by users\n */\ncontract FundingNFT is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC1155Upgradeable {\n    using TokenFormat for uint256;\n\n    // Events\n    event GenerationIncreased(\n        uint256 indexed loanId,\n        address indexed user,\n        uint256 newGeneration\n    );\n    event GenerationDecreased(\n        uint256 indexed loanId,\n        address indexed user,\n        uint256 newGeneration\n    );\n    event TransfersPaused(uint256 loanId);\n    event TransfersResumed(uint256 loanId);\n\n    // contract URI for marketplaces\n    string private _contractURI;\n\n    // base url for each token metadata. Concatenates with ipfsHash for full path\n    string private _baseURI;\n\n    // Mapping from loan ID to paused condition\n    mapping(uint256 => bool) public transfersPaused;\n\n    // Mapping from token ID to IPFS hash (token metadata)\n    mapping(uint256 => string) public ipfsHashes;\n\n    // Access Roles\n    bytes32 public MINTER_ROLE;\n    bytes32 public PAUSER_ROLE;\n\n    /**\n     * @dev Initializes the contract\n     */\n    function initialize(string memory baseUri, string memory contractUri) public initializer {\n        MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n        PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n        __ERC1155_init(\"\");\n        __ERC1155_init_unchained(\"\");\n        _baseURI = baseUri;\n        _contractURI = contractUri;\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    modifier onlyPauser() {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"Must have pauser role\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(\n            hasRole(MINTER_ROLE, _msgSender()),\n            \"Must have minter role to mint\"\n        );\n        _;\n    }\n\n    // /**\n    // * @dev token metadata\n    // */\n    // function uri(uint tokenId) public view override returns(string memory){\n    //     return Strings.strConcat(_baseURI, ipfsHashes[tokenId]);\n    // }\n\n    /**\n     * @dev contract metadata\n     */\n    function contractURI() public view returns (string memory) {\n        return _contractURI;\n    }\n\n    /**\n     * @dev Owner can pause transfers for specific tokens\n     * @dev pauses all loan ids, no matter the generation\n     */\n    function pauseTokenTransfer(uint256 loanId) external onlyPauser {\n        transfersPaused[loanId] = true;\n        emit TransfersPaused(loanId);\n    }\n\n    /**\n     * @dev Owner can unpause transfers for specific tokens\n     */\n    function unpauseTokenTransfer(uint256 loanId) external onlyPauser {\n        transfersPaused[loanId] = false;\n        emit TransfersResumed(loanId);\n    }\n\n    /**\n     * @dev Mint generation 0 tokens\n     */\n    function mintGen0(address to, uint256 amount, uint256 loanId) external onlyMinter {\n        // LoanId is the tokenId used to mint\n        _mint(to, loanId, amount, \"\");\n    }\n\n    /**\n     * @dev Mint tokens of a specific generation directly\n     * @param to The address to mint the tokens to.\n     * @param amount The amount of tokens to mint.\n     * @param generation The generation of the tokens. The id of the tokens will be composed of the loan id and this generation number.\n     * @param loanId The loan identifier\n     */\n    function mintOfGen(\n        address to,\n        uint256 amount,\n        uint256 generation,\n        uint256 loanId\n    ) external onlyMinter {\n        uint256 tokenId = generation.getTokenId(loanId);\n        _mint(to, tokenId, amount, \"\");\n    }\n\n    /**\n     * @notice decrease generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     */\n    function decreaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToDecrease\n    ) external onlyMinter {\n        _decreaseGenerations(tokenId, user, amount, generationsToDecrease);\n    }\n\n    /**\n     * @notice increase generation of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     */\n    function increaseGeneration(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external onlyMinter {\n        _increaseGenerations(tokenId, user, amount, 1);\n    }\n\n    /**\n     * @notice increase generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     */\n    function increaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToAdd\n    ) external onlyMinter {\n        _increaseGenerations(tokenId, user, amount, generationsToAdd);\n    }\n\n    function burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) public onlyMinter {\n        _burn(account, id, amount);\n    }\n\n    /**\n     * @notice increase multiple generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     */\n    function _increaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToAdd\n    ) internal {\n        (uint256 generation, uint256 loanId) = tokenId.formatTokenId();\n\n        // Increase generation, leave loanId same\n        generation += generationsToAdd;\n        uint256 newTokenId = generation.getTokenId(loanId);\n\n        // Burn previous gen tokens\n        burn(user, tokenId, amount);\n\n        // Mint new generation tokens\n        _mint(user, newTokenId, amount, \"\");\n\n        emit GenerationIncreased(loanId, user, generation);\n    }\n\n    /**\n     * @notice decrease multiple generations of a token\n     * @dev token is burned, and new token is minted to user\n     * @dev token owner should have approvedForAll before calling this function\n     */\n    function _decreaseGenerations(\n        uint256 tokenId,\n        address user,\n        uint256 amount,\n        uint256 generationsToDecrease\n    ) internal {\n        (uint256 generation, uint256 loanId) = tokenId.formatTokenId();\n\n        require(generation >= generationsToDecrease, \"Invalid token ID\");\n\n        // Decrease generation, leave loanId same\n        generation -= generationsToDecrease;\n        uint256 newTokenId = generation.getTokenId(loanId);\n\n        // Burn previous gen tokens\n        burn(user, tokenId, amount);\n\n        // Mint new generation tokens\n        _mint(user, newTokenId, amount, \"\");\n\n        emit GenerationDecreased(loanId, user, generation);\n    }\n\n    /**\n     * @dev Validates if the loanId from the tokenId can be transferred\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override {\n        for (uint256 i = 0; i < ids.length; i++) {\n            (, uint256 loanId) = ids[i].formatTokenId();\n            require(!transfersPaused[loanId], \"Transfers paused\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155MetadataURIUpgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSetUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using AddressUpgradeable for address;\n\n    struct RoleData {\n        EnumerableSetUpgradeable.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\n"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nlibrary Strings {\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\n        );\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        for (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c)\n        internal\n        pure\n        returns (string memory)\n    {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721MetadataUpgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/EnumerableSetUpgradeable.sol\";\nimport \"../../utils/EnumerableMapUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;\n    using StringsUpgradeable for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721ReceiverUpgradeable(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n    uint256[41] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMapUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    function __ERC1155Receiver_init_unchained() internal initializer {\n        _registerInterface(\n            ERC1155ReceiverUpgradeable(address(0)).onERC1155Received.selector ^\n            ERC1155ReceiverUpgradeable(address(0)).onERC1155BatchReceived.selector\n        );\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n        __ERC1155Holder_init_unchained();\n    }\n\n    function __ERC1155Holder_init_unchained() internal initializer {\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol\";\nimport \"./libs/LoanLibrary.sol\";\nimport \"./EscrowDetails.sol\";\nimport \"./rALBT.sol\";\n\n/**\n * @title AllianceBlock Escrow contract\n * @notice Responsible for handling the funds in AllianceBlock's ecosystem.\n */\ncontract Escrow is Initializable, EscrowDetails, OwnableUpgradeable, ERC1155HolderUpgradeable {\n    /**\n     * @dev Initializes the contract.\n     * @param lendingToken_ The token that lenders will be able to lend.\n     * @param mainNFT_ The ERC721 token contract which will represent the whole loans.\n     * @param fundingNFT_ The ERC1155 token contract which will represent the lending amounts.\n     */\n    function initialize(\n        address lendingToken_,\n        address mainNFT_,\n        address fundingNFT_\n    ) public initializer {\n        __Ownable_init();\n        lendingToken = IERC20(lendingToken_);\n        mainNFT = IERC721Mint(mainNFT_);\n        fundingNFT = IERC1155Mint(fundingNFT_);\n        reputationalALBT = new rALBT();\n    }\n\n    /**\n     * @dev Initializes the contract.\n     * @param registryAddress_ The registry address.\n     * @param actionVerifierAddress_ The actionVerifier address.\n     * @param stakingAddress_ The staking address\n     */\n    function afterInitialize(\n        address registryAddress_,\n        address actionVerifierAddress_,\n        address stakingAddress_\n    ) external onlyOwner() {\n        require(address(registry) == address(0), \"Cannot initialize registry second time\");\n        require(address(actionVerifier) == address(0), \"Cannot initialize actionVerifier second time\");\n        require(address(staking) == address(0), \"Cannot initialize staking second time\");\n        registry = IRegistry(registryAddress_);\n        actionVerifier = actionVerifierAddress_;\n        staking = stakingAddress_;\n    }\n\n    /**\n     * @dev This function is used to send the ERC1155 tokens from escrow to the lenders.\n     * @param loanId The id of the loan.\n     * @param partitionsPurchased The amount of ERC1155 tokens that should be sent back to the lender.\n     * @param receiver Lender's address.\n     */\n    function transferFundingNFT(\n        uint256 loanId,\n        uint256 partitionsPurchased,\n        address receiver\n    ) external onlyRegistry() {\n        fundingNFT.safeTransferFrom(address(this), receiver, loanId, partitionsPurchased, \"\");\n    }\n\n    /**\n     * @dev This function is used to send the lended amount to the seeker.\n     * @param seeker Seeker's address.\n     * @param amount The amount of lending tokens to be sent to seeker.\n     */\n    function transferLendingToken(address seeker, uint256 amount) external onlyRegistry() {\n        lendingToken.transfer(seeker, amount);\n    }\n\n    /**\n     * @dev This function is used to send the collateral amount to the seeker.\n     * @param collateralToken The collateral token's contract address.\n     * @param recipient The address to transfer the collateral tokens to.\n     * @param amount The amount of collateral tokens to be sent to seeker.\n     */\n    function transferCollateralToken(\n        address collateralToken,\n        address recipient,\n        uint256 amount\n    ) external onlyRegistry() {\n        IERC20(collateralToken).transfer(recipient, amount);\n    }\n\n    /**\n     * @dev This function is used to multi mint reputational tokens.\n     * @param recipients The addresses to mint the reputational tokens to.\n     * @param amounts The amounts of reputational tokens to be minted.\n     */\n    function multiMintReputationalToken(\n        address[] memory recipients,\n        uint256[] memory amounts\n    ) external onlyActionVerifier() {\n        reputationalALBT.multiMintTo(recipients, amounts);\n    }\n\n    /**\n     * @dev This function is used to mint reputational tokens.\n     * @param recipient The address to mint the reputational tokens to.\n     * @param amount The amount of reputational tokens to be minted.\n     */\n    function mintReputationalToken(\n        address recipient,\n        uint256 amount\n    ) external onlyRegistryOrStaking() {\n        reputationalALBT.mintTo(recipient, amount);\n    }\n\n    /**\n     * @dev This function is used to burn reputational tokens.\n     * @param from The address to burn the reputational tokens from.\n     * @param amount The amount of reputational tokens to be burnt.\n     */\n    function burnReputationalToken(\n        address from,\n        uint256 amount\n    ) external onlyStaking() {\n        reputationalALBT.burnFrom(from, amount);\n    }\n\n    /**\n     * @dev This function is used to change the registry address in case of an upgrade.\n     * @param registryAddress The address of the upgraded Registry contract.\n     */\n    function changeRegistry(address registryAddress) external onlyOwner() {\n        registry = IRegistry(registryAddress);\n    }\n}\n"
    },
    "contracts/EscrowDetails.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IERC1155Mint.sol\";\nimport \"./interfaces/IERC721Mint.sol\";\nimport \"./libs/LoanLibrary.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./rALBT.sol\";\n\n/**\n * @title AllianceBlock EscrowDetails contract\n * @notice Functionality, storage and modifiers for escrow\n */\ncontract EscrowDetails {\n    IRegistry public registry;\n\n    IERC20 public lendingToken;\n    IERC721Mint public mainNFT;\n    IERC1155Mint public fundingNFT;\n    address public actionVerifier;\n    address public staking;\n\n    mapping(uint256 => address) public loanSeeker;\n    rALBT public reputationalALBT;\n\n    modifier onlyRegistry() {\n        require(msg.sender == address(registry), \"Only Registry\");\n        _;\n    }\n\n    modifier onlyActionVerifier() {\n        require(msg.sender == actionVerifier, \"Only Action Verifier\");\n        _;\n    }\n\n    modifier onlyStaking() {\n        require(msg.sender == staking, \"Only Staking\");\n        _;\n    }\n\n    modifier onlyRegistryOrStaking() {\n        require(msg.sender == staking || msg.sender == address(registry),\n            \"Only Registry or Staking\");\n        _;\n    }\n}\n"
    },
    "contracts/rALBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract rALBT is Ownable {\n\tusing SafeMath for uint256;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\tstring constant NAME = \"Reputational AllianceBlock Token\"; // The name of the token\n\tstring constant SYMBOL = \"rALBT\"; // The symbol of the token\n    uint256 _totalSupply;\n\n    mapping (address => uint256) private _balances;\n\n    /**\n     * @dev Multimints tokens.\n     * @param to The addresses that will be minted tokens.\n     * @param amounts The amounts of tokens to be minted.\n     */\n    function multiMintTo(address[] memory to, uint256[] memory amounts) external onlyOwner() {\n        require(to.length == amounts.length, \"Invalid length of to or amounts\");\n\n        for (uint256 i = 0; i < to.length; i++) {\n            if (to[i] != address(0)) _mint(to[i], amounts[i]);\n        }\n    }\n\n    /**\n     * @dev Mints amountToMint tokens to the sender\n     * @param amountToMint The amount of tokens to be minted\n     */\n    function mintTo(address to, uint256 amountToMint) external onlyOwner() {\n    \t_mint(to, amountToMint);\n    }\n\n    /**\n     * @dev Burns amountToBurn tokens from the sender\n     * @param amountToBurn The amount of tokens to be burnt\n     */\n    function burnFrom(address from, uint256 amountToBurn) external onlyOwner() {\n    \t_burn(from, amountToBurn);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return NAME;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return SYMBOL;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n}\n"
    },
    "contracts/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the Registry contract.\n */\ninterface IRegistry {\n    function decideForLoan(uint256 loanId, bool decision) external;\n    function decideForMilestone(uint256 loanId, bool decision) external;\n    function getRequestingInterestStatus(uint256 investmentId) external view returns (bool);\n    function startLotteryPhase(uint256 investmentId) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/governance/DaoCronjob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./GovernanceTypesAndStorage.sol\";\nimport \"../interfaces/IRegistry.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @notice Responsible for governing AllianceBlock's ecosystem\n */\ncontract DaoCronjob is GovernanceTypesAndStorage {\n    using SafeMath for uint256;\n    using ValuedDoubleLinkedList for ValuedDoubleLinkedList.LinkedList;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    modifier checkCronjob() {\n        checkCronjobs();\n        _;\n    }\n\n    function checkCronjobs() public returns (bool) {\n        uint256 mostRecentCronjobTimestamp = cronjobList.getHeadValue();\n        if (mostRecentCronjobTimestamp == 0 || block.timestamp < mostRecentCronjobTimestamp) return false;\n        else { // only pop head for now for gas reasons, maybe later we can execute them all together.\n            (uint256 head, uint256 timestamp) = cronjobList.popHeadAndValue();\n            executeCronjob(head, timestamp);\n        }\n\n        return true;\n    }\n\n    function executeCronjob(uint256 cronjobId, uint256 timestamp) internal {\n        if (cronjobs[cronjobId].cronjobType == CronjobType.DAO_APPROVAL) {\n            executeDaoApproval(cronjobs[cronjobId].externalId);\n        }\n        else if (cronjobs[cronjobId].cronjobType == CronjobType.DAO_VOTING_REQUEST) {\n            // TODO - executeDaoRequest(cronjobs[cronjobId].externalId);\n        }\n        else if (cronjobs[cronjobId].cronjobType == CronjobType.DAO_MEMBERSHIP_VOTING) {\n            updateDaoMembershipVotingState(timestamp);\n        }\n        else if (cronjobs[cronjobId].cronjobType == CronjobType.DAO_DELEGATORS_VOTING) {\n            updateDaoDelegationVotingState(timestamp);\n        }\n        else if (cronjobs[cronjobId].cronjobType == CronjobType.DAO_REWARDS_PROVISION) {\n            staking.provideRewards(\n                rewardsForDaoMembersPerEpoch[currentEpoch.sub(1)],\n                rewardsForDaoDelegatorsPerEpoch[currentEpoch.sub(1)],\n                currentEpoch.sub(1)\n            );\n        }\n        else if (cronjobs[cronjobId].cronjobType == CronjobType.DAO_SUBSTITUTES) {\n            updateSubstitutes();\n        }\n        else {\n            updateInvestment(cronjobs[cronjobId].externalId, timestamp);\n        }\n    }\n\n    function addCronjob(CronjobType cronjobType, uint256 timestamp, uint256 externalId) internal {\n        totalCronjobs = totalCronjobs.add(1);\n        cronjobs[totalCronjobs] = Cronjob(cronjobType, externalId);\n        cronjobList.addNodeIncrement(timestamp, totalCronjobs);\n    }\n\n    function removeCronjob(uint256 cronjobId) internal {\n        cronjobList.removeNode(cronjobId);\n    }\n\n    function updateInvestment(uint256 investmentId, uint256 timestamp) internal {\n        if (registry.getRequestingInterestStatus(investmentId)) {\n            registry.startLotteryPhase(investmentId);\n        }\n        else {\n            uint256 nextCronjobTimestamp = timestamp.add(\n                updatableVariables[keccak256(abi.encode(\"lateApplicationsForInvestmentDuration\"))]);\n            addCronjob(CronjobType.INVESTMENT, nextCronjobTimestamp, investmentId);\n        }\n    }\n\n    function updateDaoMembershipVotingState(uint256 timestamp) internal {\n        uint256 nextCronjobTimestamp;\n\n        if (votingStatusForDaoMembers == VotingStatusMembers.VOTING) {\n            amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)] = updatableVariables[keccak256(abi.encode(\"amountOfDaoMembers\"))];\n            votingStatusForDaoMembers = VotingStatusMembers.CLAIM_MEMBERSHIP;\n\n            nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoClaimingDuration\"))]);\n            addCronjob(CronjobType.DAO_MEMBERSHIP_VOTING, nextCronjobTimestamp, 0);\n        }\n        else if (votingStatusForDaoMembers == VotingStatusMembers.CLAIM_MEMBERSHIP) {\n            uint256 nodesToRemove = amountOfEpochDaoMembersNeededPerEpoch[currentEpoch];\n            if (daoMembersListForUpcomingEpoch.getSize() < amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)].mul(2)) {\n                nodesToRemove = amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)].mul(2).sub(daoMembersListForUpcomingEpoch.getSize());\n            }\n            if (nodesToRemove > 0) {\n                daoMembersListForUpcomingEpoch.removeMultipleFromHead(nodesToRemove);\n            }\n\n            votingStatusForDaoMembers = VotingStatusMembers.LATE_MEMBERSHIP_CLAIMING;\n\n            if (updatableVariables[keccak256(abi.encode(\"daoMembershipVotingDuration\"))] == 0) {\n                nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoLateClaimingDuration\"))]);\n                addCronjob(CronjobType.DAO_MEMBERSHIP_VOTING, nextCronjobTimestamp, 0);\n            }\n        }\n        else { // ONLY FOR FIRST EPOCH\n            delete daoMembersListForUpcomingEpoch;\n\n            currentEpoch = 1;\n        }\n    }\n\n    function updateDaoDelegationVotingState(uint256 timestamp) internal {\n        uint256 nextCronjobTimestamp;\n\n        if (votingStatusForDaoDelegators == VotingStatusDelegators.VOTING) {\n            votingStatusForDaoDelegators = VotingStatusDelegators.APPROVE_VOTING;\n\n            nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoDelegationApprovalDuration\"))]);\n        }\n        else if (votingStatusForDaoDelegators == VotingStatusDelegators.APPROVE_VOTING) {\n            // TODO_MAYBE - Check DAO_MEMBERS not voted - Better provide rALBT to them for voting.\n            amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch.add(1)] = updatableVariables[keccak256(abi.encode(\"amountOfDaoDelegators\"))];\n            votingStatusForDaoDelegators = VotingStatusDelegators.CLAIM_DELEGATION;\n\n            nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoClaimingDuration\"))]);\n        }\n        else if (votingStatusForDaoDelegators == VotingStatusDelegators.CLAIM_DELEGATION) {\n            uint256 nodesToRemove = amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch];\n            if (daoMembersListForUpcomingEpoch.getSize() < amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch.add(1)].mul(2)) {\n                nodesToRemove = amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch.add(1)].mul(2).sub(daoDelegatorsListForUpcomingEpoch.getSize());\n            }\n            if (nodesToRemove > 0) {\n                daoDelegatorsListForUpcomingEpoch.removeMultipleFromHead(nodesToRemove);\n            }\n\n            votingStatusForDaoDelegators = VotingStatusDelegators.LATE_DELEGATION_CLAIMING;\n\n            nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoLateClaimingDuration\"))]);\n        }\n        else {\n            nextCronjobTimestamp = changeEpoch(timestamp);\n        }\n\n        addCronjob(CronjobType.DAO_DELEGATORS_VOTING, nextCronjobTimestamp, 0);\n    }\n\n    function changeEpoch(uint256 timestamp) internal returns (uint256) {\n        daoDelegatorsListForUpcomingEpoch.cloneList(daoSubstituteDelegatorsListForCurrentEpoch);\n\n        delete daoMembersListForUpcomingEpoch;\n        delete daoDelegatorsListForUpcomingEpoch;\n\n        votingStatusForDaoMembers = VotingStatusMembers.VOTING;\n        votingStatusForDaoDelegators = VotingStatusDelegators.VOTING;\n\n        uint256 nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoMembershipVotingDuration\"))]);\n        addCronjob(CronjobType.DAO_MEMBERSHIP_VOTING, nextCronjobTimestamp, 0);\n\n        nextCronjobTimestamp = timestamp.add(updatableVariables[keccak256(abi.encode(\"daoDelegationVotingDuration\"))]);\n\n        uint256 requestsRemaining = requestsPerEpoch[currentEpoch].getSize();\n\n        if (requestsRemaining == 0) {\n            staking.provideRewards(\n                rewardsForDaoMembersPerEpoch[currentEpoch],\n                rewardsForDaoDelegatorsPerEpoch[currentEpoch],\n                currentEpoch\n            );\n        }\n        else {\n            uint256 latestRequestDeadlineTimestamp = checkTimestampOfLastRequestForCurrentEpoch(requestsRemaining);\n            addCronjob(CronjobType.DAO_REWARDS_PROVISION, latestRequestDeadlineTimestamp, 0);\n        }\n\n        currentEpoch = currentEpoch.add(1);\n\n        return nextCronjobTimestamp;\n    }\n\n    function executeDaoApproval(uint256 requestId) internal {\n        uint256 approvalsNeeded = updatableVariables[keccak256(abi.encode(\"approvalsNeededForRegistryRequest\"))];\n        requestsPerEpoch[approvalRequests[requestId].epochSubmitted].removeNode(requestId);\n\n        bool decision = false;\n        if (approvalRequests[requestId].approvalsProvided >= approvalsNeeded) {\n            decision = true;\n            approvalRequests[requestId].isApproved = true;\n        }\n\n        approvalRequests[requestId].isMilestone ?\n            registry.decideForMilestone(approvalRequests[requestId].loanId, decision) :\n            registry.decideForLoan(approvalRequests[requestId].loanId, decision);\n\n        uint256 numberOfNonVotingDelegators = remainingDelegatorIdsToVotePerRequest[requestId].getSize();\n\n        if (numberOfNonVotingDelegators > 0) {\n            penaltizeDelegatorsForNonVoting(numberOfNonVotingDelegators, approvalRequests[requestId].epochSubmitted, requestId);\n        }\n    }\n\n    function checkTimestampOfLastRequestForCurrentEpoch(uint256 requestsRemaining) internal returns (uint256) {\n        uint256 latestRequestDeadlineTimestamp;\n\n        for (uint256 i = 1; i <= requestsRemaining; i++) {\n            uint256 id = requestsPerEpoch[currentEpoch].getIndexedId(i);\n\n            if (approvalRequests[id].deadlineTimestamp > latestRequestDeadlineTimestamp) {\n                latestRequestDeadlineTimestamp = approvalRequests[id].deadlineTimestamp;\n            }\n        }\n\n        return latestRequestDeadlineTimestamp;\n    }\n\n    function penaltizeDelegatorsForNonVoting(\n        uint256 amountOfPenaltizedDelegators,\n        uint256 epochOfRequest,\n        uint256 requestId\n    )\n    internal\n    {\n        bool isEpochOfRequestSameAsCurrent = currentEpoch == epochOfRequest;\n\n        uint256 amountOfSubstitutes;\n\n        for (uint256 i = 0; i < amountOfPenaltizedDelegators; i++) {\n            uint256 idToPenaltize = remainingDelegatorIdsToVotePerRequest[requestId].popHead();\n\n            epochDaoDelegators[epochOfRequest].removeNode(idToPenaltize);\n            isEpochDaoDelegator[idToAddress[idToPenaltize]][epochOfRequest] = false;\n            bannedDelegator[idToPenaltize][epochOfRequest.add(1)] = true;\n\n            // If he is substitute for current epoch should be removed as well.\n            daoSubstituteDelegatorsListForCurrentEpoch.removeNode(idToPenaltize);\n\n            removePenaltizedDelegatorFromActiveRequests(idToPenaltize, epochOfRequest);\n\n            // If he is delegator in current epoch, while current is different that epochOfRequest and should get penaltized.\n            if (!isEpochOfRequestSameAsCurrent && isEpochDaoDelegator[idToAddress[idToPenaltize]][currentEpoch]) {\n                epochDaoDelegators[currentEpoch].removeNode(idToPenaltize);\n                isEpochDaoDelegator[idToAddress[idToPenaltize]][currentEpoch] = false;\n\n                removePenaltizedDelegatorFromActiveRequests(idToPenaltize, currentEpoch);\n\n                amountOfSubstitutes = amountOfSubstitutes.add(1);\n            }\n\n            // Remove from voting list for next epoch.\n            if (isEpochOfRequestSameAsCurrent) {\n                daoDelegatorsListForUpcomingEpoch.removeNode(idToPenaltize);\n            }\n        }\n\n        if (isEpochOfRequestSameAsCurrent) amountOfSubstitutes = amountOfPenaltizedDelegators;\n\n        if (amountOfSubstitutes > 0) requestSubstitutes(amountOfSubstitutes);\n    }\n\n    function removePenaltizedDelegatorFromActiveRequests(uint256 delegatorId, uint256 epoch) internal {\n        uint256 requestsRemaining = requestsPerEpoch[epoch].getSize();\n\n        if (requestsRemaining > 0) {\n            for (uint256 i = 1; i <= requestsRemaining; i++) {\n                uint256 id = requestsPerEpoch[epoch].getIndexedId(i);\n\n                remainingDelegatorIdsToVotePerRequest[id].removeNode(delegatorId);\n            }\n        }\n    }\n\n    function addSubstituteToAllActiveRequests(uint256 delegatorId, uint256 epoch) internal {\n        uint256 requestsRemaining = requestsPerEpoch[epoch].getSize();\n\n        if (requestsRemaining > 0) {\n            for (uint256 i = 1; i <= requestsRemaining; i++) {\n                uint256 id = requestsPerEpoch[epoch].getIndexedId(i);\n\n                remainingDelegatorIdsToVotePerRequest[id].addNode(delegatorId);\n            }\n        }\n    }\n\n    function updateSubstitutes() internal {\n        if (amountOfSubstitutesRequested[currentEpoch] > 0) {\n            for (uint256 i = 0; i < amountOfSubstitutesRequested[currentEpoch]; i++) {\n                daoSubstituteDelegatorsListForCurrentEpoch.popHead();\n            }\n\n            addCronjob(\n                CronjobType.DAO_SUBSTITUTES,\n                block.timestamp.add(updatableVariables[keccak256(abi.encode(\"daoDelegationSubstituteClaimDuration\"))]),\n                0\n            );\n        }\n    }\n\n    function requestSubstitutes(uint256 amountOfSubstitutes) internal {\n        amountOfSubstitutesRequested[currentEpoch] = amountOfSubstitutes;\n\n        addCronjob(\n            CronjobType.DAO_SUBSTITUTES,\n            block.timestamp.add(updatableVariables[keccak256(abi.encode(\"daoDelegationSubstituteClaimDuration\"))]),\n            0\n        );\n    }\n}\n"
    },
    "contracts/governance/GovernanceTypesAndStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../libs/ValuedDoubleLinkedList.sol\";\nimport \"../libs/DoubleLinkedList.sol\";\n\n/**\n * @title AllianceBlock GovernanceStorage contract\n * @notice Responsible for governance storage\n */\ncontract GovernanceTypesAndStorage {\n    using ValuedDoubleLinkedList for ValuedDoubleLinkedList.LinkedList;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    enum VotingStatusMembers {\n        EMPTY_STATE, // The state where stakers cannot even subscribe for dao membership.\n        PRE_STATE, // The state where stakers can only subscribe for future dao membership.\n        VOTING, // The state where stakers are voting for dao delegators and members.\n        CLAIM_MEMBERSHIP, // The state where dao members are claiming their membership.\n        LATE_MEMBERSHIP_CLAIMING // The state where unclaimed spots for dao membership are filled.\n    }\n\n    enum VotingStatusDelegators {\n        PRE_STATE, // The state where active dao members can only subscribe to become future dao delegators.\n        VOTING, // The state where active dao members are voting for dao delegators.\n        APPROVE_VOTING, // The state where dao members are approving the voting for dao delegators.\n        CLAIM_DELEGATION, // The state where dao delegators are claiming their delegation privilages.\n        LATE_DELEGATION_CLAIMING // The state where unclaimed spots for dao delegation are filled.\n    }\n\n    struct ApprovalRequest {\n        uint256 loanId; // The loan id for which approcal is requested.\n        bool isMilestone; // true if approval reuested is connected to a milestone and false if not.\n        uint256 milestoneNumber; // The milestone number if is Milestone based request.\n        uint256 deadlineTimestamp; // The deadline timestamp to approve this request.\n        uint256 approvalsProvided; // The number of approvals that this request has gathered.\n        bool isApproved; // True if request is approved, false if not.\n        uint256 epochSubmitted; // The epoch that the request was submitted.\n    }\n\n    // EVENTS\n    event VotedForRequest(uint indexed loanId, uint indexed requestId, bool decision, address indexed user);\n    event ApprovalRequested(uint indexed loanId, bool indexed isMilestone, uint milestoneNumber, address indexed user);\n    event InitGovernance(address indexed registryAddress_, address indexed stakingAddress_, address indexed user);\n\n    VotingStatusMembers public votingStatusForDaoMembers;\n    VotingStatusDelegators public votingStatusForDaoDelegators;\n\n    mapping(address => mapping(uint256 => bool)) public isEpochDaoMember;\n    mapping(address => mapping(uint256 => bool)) public isEpochDaoDelegator;\n    mapping(address => mapping(uint256 => bool)) public hasVotedForRequestId;\n    mapping(uint256 => mapping(uint256 => bool)) public bannedDelegator;\n    mapping(uint256 => uint256) public amountOfEpochDaoMembersNeededPerEpoch;\n    mapping(uint256 => uint256) public amountOfEpochDaoDelegatorsNeededPerEpoch;\n\n    mapping(address => bool) public subscribedForDaoMembership;\n    mapping(address => bool) public subscribedForDaoDelegator;\n\n    mapping(uint256 => uint256) public rewardsForDaoMembersPerEpoch;\n    mapping(uint256 => uint256) public rewardsForDaoDelegatorsPerEpoch;\n\n    ValuedDoubleLinkedList.LinkedList public daoSubstituteMembersListForCurrentEpoch;\n    ValuedDoubleLinkedList.LinkedList public daoSubstituteDelegatorsListForCurrentEpoch;\n    ValuedDoubleLinkedList.LinkedList public daoMembersListForUpcomingEpoch;\n    ValuedDoubleLinkedList.LinkedList public daoDelegatorsListForUpcomingEpoch;\n\n    mapping(uint256 => DoubleLinkedList.LinkedList) public requestsPerEpoch;\n    mapping(uint256 => DoubleLinkedList.LinkedList) public remainingDelegatorIdsToVotePerRequest;\n    mapping(uint256 => DoubleLinkedList.LinkedList) public remainingMemberIdsToVoteForDelegator;\n    mapping(uint256 => DoubleLinkedList.LinkedList) public remainingMemberIdsToVotePerRequest; // For governance changes requests - TODO\n\n    mapping(uint256 => DoubleLinkedList.LinkedList) public epochDaoMembers;\n    mapping(uint256 => DoubleLinkedList.LinkedList) public epochDaoDelegators;\n\n    mapping(address => mapping(uint256 => bool)) public hasVotedForDaoMemberPerEpoch;\n    mapping(address => mapping(uint256 => bool)) public hasVotedForDaoDelegatorPerEpoch;\n    mapping(address => mapping(uint256 => bool)) public hasApprovedForDaoDelegatorPerEpoch;\n\n    mapping(address => mapping(uint256 => bytes32)) public votingHashOfDaoMembersPerEpoch;\n\n    mapping(address => uint256) public addressToId;\n    mapping(uint256 => address) public idToAddress;\n\n    uint256 public totalApprovalRequests; // The total amount of approvals requested.\n\n    address public superDelegator;\n\n    mapping(uint256 => ApprovalRequest) public approvalRequests;\n\n    IRegistry public registry;\n    IStaking public staking;\n\n    uint256 public totalIds;\n    uint256 public currentEpoch;\n\n    mapping(uint256 => uint256) public amountOfSubstitutesRequested; // This is true when a delegator substitute request is active\n\n    mapping(bytes32 => uint256) public updatableVariables;\n\n    // CRONJOB types and variables\n    enum CronjobType {\n        DAO_APPROVAL, // Cronjob type for approvals on registry requests.\n        DAO_VOTING_REQUEST, // Cronjob type for dao ecosystem change requests.\n        DAO_MEMBERSHIP_VOTING, // Cronjob type for dao membership voting.\n        DAO_DELEGATORS_VOTING, // Cronjob type for dao delegation voting.\n        DAO_REWARDS_PROVISION, // Cronjob type for rewards provision in case there is a pending request and rewards after epoch change.\n        DAO_SUBSTITUTES, // Cronjob type for dao substitutes to enter till list is renewed (if not filled).\n        INVESTMENT // Cronjob type for users to show interest for an investment.\n    }\n\n    struct Cronjob {\n        CronjobType cronjobType; // This is the cronjob type.\n        uint256 externalId; // This is the id of the request in case of dao approval, change voting request or investment.\n    }\n\n    // TODO - Make this simple linked list, not double (we don't need to remove anything else than head MAYBE).\n    ValuedDoubleLinkedList.LinkedList public cronjobList;\n    uint256 public totalCronjobs;\n\n    mapping(uint256 => Cronjob) public cronjobs; // cronjobId to Cronjob.\n\n    // MODIFIERS\n\n    modifier onlyRegistry() {\n        require(msg.sender == address(registry), \"Only Registry contract\");\n        _;\n    }\n\n    modifier onlyDaoDelegatorNotVoted(uint256 requestId, uint256 epochSubmitted) {\n        require(isEpochDaoDelegator[msg.sender][epochSubmitted], \"Only Dao Delegator for the epoch request was submitted\");\n        require(!hasVotedForRequestId[msg.sender][requestId], \"Only if not voted yet\");\n        _;\n\n        hasVotedForRequestId[msg.sender][requestId] = true;\n    }\n\n    modifier onlyBeforeDeadline(uint256 requestId) {\n        require(approvalRequests[requestId].deadlineTimestamp > block.timestamp,\n            \"Only before deadline is reached\");\n        _;\n    }\n\n    modifier onlyAfterDeadlineAndNotApproved(uint256 requestId) {\n        require(approvalRequests[requestId].deadlineTimestamp <= block.timestamp,\n            \"Only after deadline is reached\");\n        require(!approvalRequests[requestId].isApproved, \"Only if not already approved\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the Staking contract.\n */\ninterface IStaking {\n    function getBalance(address staker_) external view returns (uint256);\n\tfunction provideStakingForDaoMembership(address staker) external;\n\tfunction provideStakingForDaoDelegator(address staker) external;\n\tfunction provideRewards(uint256 amountForDaoMembers, uint256 amountForDaoDelegators, uint256 epoch) external;\n\tfunction unstakeDao(address staker, bool isDaoMember) external;\n\tfunction getAmountsToStake() external view returns (uint256, uint256, uint256);\n}\n"
    },
    "contracts/libs/ValuedDoubleLinkedList.sol": {
      "content": "pragma solidity ^0.7.0;\n\nlibrary ValuedDoubleLinkedList {\n    struct Node {\n        uint256 next;\n        uint256 previous;\n        uint256 value;\n    }\n\n    struct LinkedList {\n        uint256 head;\n        uint256 tail;\n        uint256 size;\n        mapping(uint256 => Node) nodes;\n    }\n\n    function getHeadId(LinkedList storage self) internal view returns (uint256) {\n        return self.head;\n    }\n\n    function getHeadValue(LinkedList storage self) internal view returns (uint256) {\n        return self.nodes[self.head].value;\n    }\n\n    function getSize(LinkedList storage self) internal view returns (uint256) {\n        return self.size;\n    }\n\n    function addNodeIncrement(\n        LinkedList storage self,\n        uint256 value,\n        uint256 id\n    ) internal {\n        Node memory node = self.nodes[self.head];\n\n        //If empty\n        if (self.head == 0) {\n            self.head = id;\n            self.tail = id;\n            self.nodes[id] = Node(0, 0, value);\n        }\n        //If head\n        else if (value < node.value) {\n            self.nodes[self.head].previous = id;\n            self.nodes[id] = Node(self.head, 0, value);\n            self.head = id;\n        }\n        else {\n            //If middle\n            if(self.size > 1) {\n                for (uint256 i = 1; i < self.size; i++) {\n                    node = self.nodes[node.next];\n                    if (value < node.value) {\n                        uint256 currentId = self.nodes[node.next].previous;\n                        self.nodes[node.next].previous = id;\n                        self.nodes[id] = Node(\n                            currentId,\n                            self.nodes[currentId].next,\n                            value\n                        );\n                        self.nodes[currentId].next = id;\n                        break;\n                    }\n                }\n            }\n            //If tail\n            if (self.nodes[id].value != value) {\n                self.nodes[id] = Node(0, self.tail, value);\n                self.nodes[self.tail].next = id;\n                self.tail = id;\n            }\n        }\n\n        self.size += 1;\n    }\n\n    function addNodeDecrement(\n        LinkedList storage self,\n        uint256 value,\n        uint256 id\n    ) internal {\n        Node memory node = self.nodes[self.head];\n\n        //If empty\n        if (self.head == 0) {\n            self.head = id;\n            self.tail = id;\n            self.nodes[id] = Node(0, 0, value);\n        }\n        //If head\n        else if (value > node.value) {\n            self.nodes[self.head].previous = id;\n            self.nodes[id] = Node(self.head, 0, value);\n            self.head = id;\n        }\n        else {\n            //If middle\n            if (self.size > 1) {\n                for (uint256 i = 1; i < self.size; i++) {\n                    node = self.nodes[node.next];\n                    if (value > node.value) {\n                        uint256 currentId = self.nodes[node.next].previous;\n                        self.nodes[node.next].previous = id;\n                        self.nodes[id] = Node(\n                            currentId,\n                            self.nodes[currentId].next,\n                            value\n                        );\n                        self.nodes[currentId].next = id;\n                        break;\n                    }\n                }\n            }\n            //If tail\n            if (self.nodes[id].value != value) {\n                self.nodes[id] = Node(0, self.tail, value);\n                self.nodes[self.tail].next = id;\n                self.tail = id;\n            }\n        }\n\n        self.size += 1;\n    }\n\n    function removeNode(LinkedList storage self, uint256 id) internal {\n        if (self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        }\n        else if (id == self.head) {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }\n        else if (id == self.tail) {\n            self.tail = self.nodes[self.tail].previous;\n            self.nodes[self.tail].next = 0;\n        }\n        else {\n            self.nodes[self.nodes[id].next].previous = self.nodes[id].previous;\n            self.nodes[self.nodes[id].previous].next = self.nodes[id].next;\n        }       \n\n        self.size -= 1;\n    }\n\n    function popHead(LinkedList storage self) internal returns(uint256 head) {\n        head = self.head;\n\n        if(self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        }\n        else {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }      \n\n        self.size -= 1;\n    }\n\n    function popHeadAndValue(LinkedList storage self) internal returns(uint256 head, uint256 value) {\n        head = self.head;\n        value = self.nodes[self.head].value;\n\n        if(self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        }\n        else {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }      \n\n        self.size -= 1;\n    }\n\n    function removeMultipleFromHead(LinkedList storage self, uint256 amountOfNodes) internal {\n        for (uint256 i = 0; i < amountOfNodes; i++) {\n            uint256 head = self.head;\n\n            if(self.size == 1) {\n                self.head = 0;\n                self.tail = 0;\n            }\n            else {\n                self.head = self.nodes[self.head].next;\n                self.nodes[self.head].previous = 0;\n            }      \n\n            self.size -= 1;\n        }\n    }\n\n    function getPositionForId(LinkedList storage self, uint256 id) internal view returns(uint256) {\n        uint256 positionCounter;\n\n        if (self.nodes[id].value == 0) return 0; // If not in list.\n\n        while (true) {\n            positionCounter += 1;\n            if (id == self.head) break;\n\n            id = self.nodes[id].previous;\n        }\n\n        return positionCounter;\n    }\n\n    function cloneList(LinkedList storage self, LinkedList storage listToClone) internal {\n        self.head = listToClone.head;\n        self.tail = listToClone.tail;\n        self.size = listToClone.size;\n\n        uint256 id = listToClone.head;\n\n        for (uint256 i = 0; i < listToClone.size; i++) {\n            self.nodes[id] = listToClone.nodes[id];\n            id = listToClone.nodes[id].next;\n        }\n    }\n}\n"
    },
    "contracts/libs/DoubleLinkedList.sol": {
      "content": "pragma solidity ^0.7.0;\n\nlibrary DoubleLinkedList {\n    struct Node {\n        uint256 next;\n        uint256 previous;\n    }\n\n    struct LinkedList {\n        uint256 head;\n        uint256 tail;\n        uint256 size;\n        mapping(uint256 => Node) nodes;\n    }\n\n    function getHeadId(LinkedList storage self) internal view returns (uint256) {\n        return self.head;\n    }\n\n    function getSize(LinkedList storage self) internal view returns (uint256) {\n        return self.size;\n    }\n\n    function addNode(\n        LinkedList storage self,\n        uint256 id\n    ) internal {\n        //If empty\n        if (self.head == 0) {\n            self.head = id;\n            self.tail = id;\n            self.nodes[id] = Node(0, 0);\n        }\n        //Else push in tail\n        else {\n            self.nodes[self.tail].next = id;\n            self.nodes[id] = Node(0, self.tail);\n            self.tail = id;\n        }\n\n        self.size += 1;\n    }\n\n    function removeNode(LinkedList storage self, uint256 id) internal {\n        if(self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        }\n        else if (id == self.head) {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }\n        else if (id == self.tail) {\n            self.tail = self.nodes[self.tail].previous;\n            self.nodes[self.tail].next = 0;\n        }\n        else {\n            self.nodes[self.nodes[id].next].previous = self.nodes[id].previous;\n            self.nodes[self.nodes[id].previous].next = self.nodes[id].next;\n        }       \n\n        self.size -= 1;\n    }\n\n    function popHead(LinkedList storage self) internal returns(uint256 head) {\n        head = self.head;\n\n        if(self.size == 1) {\n            self.head = 0;\n            self.tail = 0;\n        }\n        else {\n            self.head = self.nodes[self.head].next;\n            self.nodes[self.head].previous = 0;\n        }      \n\n        self.size -= 1;\n    }\n\n    function getIndexedId(LinkedList storage self, uint256 index) internal returns(uint256 id) {\n        id = self.head;\n\n        for (uint256 i = 1; i < index; i++) {\n            id = self.nodes[id].next;\n        }\n    }\n\n    function cloneList(LinkedList storage self, LinkedList storage listToClone) internal {\n        self.head = listToClone.head;\n        self.tail = listToClone.tail;\n        self.size = listToClone.size;\n\n        uint256 id = listToClone.head;\n\n        for (uint256 i = 0; i < listToClone.size; i++) {\n            self.nodes[id] = listToClone.nodes[id];\n            id = listToClone.nodes[id].next;\n        }\n    }\n}\n"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"./governance/DaoSubscriptions.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @notice Responsible for governing AllianceBlock's ecosystem\n */\ncontract Governance is Initializable, DaoSubscriptions {\n    using SafeMath for uint256;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    /**\n     * @dev Initialize the contract.\n     */\n    function initialize(\n        address superDelegator_,\n        uint256 loanApprovalRequestDuration_,\n        uint256 milestoneApprovalRequestDuration_,\n        uint256 daoUpdateRequestDuration_,\n        uint256 approvalsNeededForRegistryRequest_,\n        uint256 approvalsNeededForGovernanceRequest_,\n        uint256 applicationsForInvestmentDuration_,\n        uint256 lateApplicationsForInvestmentDuration_\n    ) public initializer {\n        __Ownable_init();\n\n        superDelegator = superDelegator_;\n\n        updatableVariables[keccak256(abi.encode(\"loanApprovalRequestDuration\"))] = loanApprovalRequestDuration_;\n        updatableVariables[keccak256(abi.encode(\"milestoneApprovalRequestDuration\"))] = milestoneApprovalRequestDuration_;\n        updatableVariables[keccak256(abi.encode(\"daoUpdateRequestDuration\"))] = daoUpdateRequestDuration_;\n        updatableVariables[keccak256(abi.encode(\"approvalsNeededForRegistryRequest\"))] = approvalsNeededForRegistryRequest_;\n        updatableVariables[keccak256(abi.encode(\"approvalsNeededForGovernanceRequest\"))] = approvalsNeededForGovernanceRequest_;\n        updatableVariables[keccak256(abi.encode(\"applicationsForInvestmentDuration\"))] = applicationsForInvestmentDuration_;\n        updatableVariables[keccak256(abi.encode(\"lateApplicationsForInvestmentDuration\"))] = lateApplicationsForInvestmentDuration_;\n    }\n\n    function requestApproval(\n    \tuint256 loanId,\n        bool isMilestone,\n        uint256 milestoneNumber\n    )\n    external\n    onlyRegistry()\n    checkCronjob()\n    {\n        approvalRequests[totalApprovalRequests].loanId = loanId;\n        approvalRequests[totalApprovalRequests].isMilestone = isMilestone;\n        approvalRequests[totalApprovalRequests].epochSubmitted = currentEpoch;\n\n        if (isMilestone) {\n            approvalRequests[totalApprovalRequests].milestoneNumber = milestoneNumber;\n            approvalRequests[totalApprovalRequests].deadlineTimestamp =\n                block.timestamp.add(updatableVariables[keccak256(abi.encode(\"milestoneApprovalRequestDuration\"))]);\n        } else {\n            approvalRequests[totalApprovalRequests].deadlineTimestamp =\n                block.timestamp.add(updatableVariables[keccak256(abi.encode(\"loanApprovalRequestDuration\"))]);\n        }\n\n        if (currentEpoch > 1) {\n            addCronjob(\n                CronjobType.DAO_APPROVAL,\n                approvalRequests[totalApprovalRequests].deadlineTimestamp,\n                totalApprovalRequests\n            );\n\n            requestsPerEpoch[currentEpoch].addNode(totalApprovalRequests);\n\n            if (epochDaoDelegators[currentEpoch].getSize() > 0) {\n                epochDaoDelegators[currentEpoch].cloneList(remainingDelegatorIdsToVotePerRequest[totalApprovalRequests]);\n            }\n        }\n\n        emit ApprovalRequested(\n            approvalRequests[totalApprovalRequests].loanId,\n            approvalRequests[totalApprovalRequests].isMilestone,\n            approvalRequests[totalApprovalRequests].milestoneNumber,\n            msg.sender\n        );\n\n        totalApprovalRequests = totalApprovalRequests.add(1);\n    }\n\n    function voteForRequest(\n        uint256 requestId,\n        bool decision\n    )\n    external\n    onlyDaoDelegatorNotVoted(requestId, approvalRequests[requestId].epochSubmitted)\n    onlyBeforeDeadline(requestId)\n    checkCronjob()\n    {\n        if (decision) {\n            approvalRequests[requestId].approvalsProvided = approvalRequests[requestId].approvalsProvided.add(1);\n        }\n\n        remainingDelegatorIdsToVotePerRequest[requestId].removeNode(addressToId[msg.sender]);\n\n        emit VotedForRequest(approvalRequests[requestId].loanId, requestId, decision, msg.sender);\n    }\n\n    function storeInvestmentTriggering(\n        uint256 investmentId\n    )\n    external\n    onlyRegistry()\n    {\n        uint256 nextCronjobTimestamp = block.timestamp.add(\n            updatableVariables[keccak256(abi.encode(\"applicationsForInvestmentDuration\"))]);\n        addCronjob(CronjobType.INVESTMENT, nextCronjobTimestamp, investmentId);\n    }\n\n    /**\n    * @dev Helper function for querying Governance variables\n    * @return internal Governance uint variables\n    */\n    function getDaoData() public view returns (uint256, uint256, uint256, uint256, uint256){\n        (, uint256 amountToStakeForDaoMember, ) = staking.getAmountsToStake();\n\n        return (\n            totalApprovalRequests,\n            updatableVariables[keccak256(abi.encode(\"approvalsNeededForRegistryRequest\"))],\n            updatableVariables[keccak256(abi.encode(\"loanApprovalRequestDuration\"))],\n            updatableVariables[keccak256(abi.encode(\"milestoneApprovalRequestDuration\"))],\n            amountToStakeForDaoMember\n        );\n    }\n}\n"
    },
    "contracts/governance/DaoSubscriptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"./SuperGovernance.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title AllianceBlock DaoSubscriptions contract\n * @notice Responsible for all dao subscriptions on AllianceBlock's ecosystem\n */\ncontract DaoSubscriptions is SuperGovernance {\n    using SafeMath for uint256;\n    using ValuedDoubleLinkedList for ValuedDoubleLinkedList.LinkedList;\n    using DoubleLinkedList for DoubleLinkedList.LinkedList;\n\n    function subscribeForDaoMembership()\n    external\n    checkCronjob()\n    {\n        require(votingStatusForDaoMembers > VotingStatusMembers.EMPTY_STATE, \"Subscriptions for Dao Membership are not open right now\");\n\n        staking.provideStakingForDaoMembership(msg.sender);\n        subscribedForDaoMembership[msg.sender] = true;\n\n        if(addressToId[msg.sender] == 0) {\n            totalIds = totalIds.add(1);\n            addressToId[msg.sender] = totalIds;\n            idToAddress[totalIds] = msg.sender;\n        }\n    }\n\n    function unsubscribeDaoMembership()\n    external\n    checkCronjob()\n    {\n        require(!isEpochDaoMember[msg.sender][currentEpoch], \"Cannot unsubscribe while being active dao member\");\n\n        subscribedForDaoMembership[msg.sender] = false;\n        staking.unstakeDao(msg.sender, true);\n    }\n\n    function voteForDaoMember(address daoSubscriberToVoteFor)\n    external\n    checkCronjob()\n    {\n        require(votingStatusForDaoMembers == VotingStatusMembers.VOTING, \"Voting for Dao Members is not open right now\");\n        require(staking.getBalance(msg.sender) > 0, \"Only stakers can vote\");\n        require(subscribedForDaoMembership[daoSubscriberToVoteFor], \"Can only vote for active dao membership subscriber\");\n        require(!hasVotedForDaoMemberPerEpoch[msg.sender][currentEpoch], \"Cannot vote again\");\n\n        hasVotedForDaoMemberPerEpoch[msg.sender][currentEpoch] = true;\n\n        uint256 votesForSubscriber = daoMembersListForUpcomingEpoch.nodes[addressToId[daoSubscriberToVoteFor]].value;\n\n        if(votesForSubscriber != 0) {\n            daoMembersListForUpcomingEpoch.removeNode(addressToId[daoSubscriberToVoteFor]);\n        }\n\n        daoMembersListForUpcomingEpoch.addNodeDecrement(votesForSubscriber.add(1), addressToId[daoSubscriberToVoteFor]);\n    }\n\n    function claimDaoMembership()\n    external\n    checkCronjob()\n    {\n        require(votingStatusForDaoMembers >= VotingStatusMembers.CLAIM_MEMBERSHIP, \"Claiming Dao Membership is not open right now\");\n        uint256 currentPosition = daoMembersListForUpcomingEpoch.getPositionForId(addressToId[msg.sender]);\n\n        require(currentPosition > 0 && currentPosition <=\n            amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)], \"Not eligible to become dao member\");\n\n        daoMembersListForUpcomingEpoch.removeNode(addressToId[msg.sender]);\n        amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)] =\n            amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)].sub(1);\n        isEpochDaoMember[msg.sender][currentEpoch.add(1)] = true;\n\n        epochDaoMembers[currentEpoch.add(1)].addNode(addressToId[msg.sender]);\n    }\n\n    function subscribeForDaoDelegator()\n    external\n    checkCronjob()\n    {\n        require(isEpochDaoMember[msg.sender][currentEpoch], \"Only active dao members can subscribe to become delegators\");\n\n        staking.provideStakingForDaoDelegator(msg.sender);\n        subscribedForDaoDelegator[msg.sender] = true;\n    }\n\n    function unsubscribeDaoDelegation()\n    external\n    checkCronjob()\n    {\n        require(!isEpochDaoDelegator[msg.sender][currentEpoch], \"Cannot unsubscribe while being active dao delegator\");\n\n        subscribedForDaoDelegator[msg.sender] = false;\n        staking.unstakeDao(msg.sender, false);\n    }\n\n    function voteForDaoDelegator(bytes32 votingHash)\n    external\n    checkCronjob()\n    {\n        require(votingStatusForDaoDelegators == VotingStatusDelegators.VOTING, \"Voting for Dao Delegators is not open right now\");\n        require(isEpochDaoMember[msg.sender][currentEpoch], \"Only dao members can vote\");\n        require(!hasVotedForDaoDelegatorPerEpoch[msg.sender][currentEpoch], \"Cannot vote again\");\n\n        hasVotedForDaoDelegatorPerEpoch[msg.sender][currentEpoch] = true;\n\n        votingHashOfDaoMembersPerEpoch[msg.sender][currentEpoch] = votingHash;\n    }\n\n    function approveVoteForDaoDelegator(string calldata password, address daoDelegatorToVoteFor)\n    external\n    checkCronjob()\n    {\n        require(votingStatusForDaoDelegators == VotingStatusDelegators.APPROVE_VOTING, \"Approve voting for Dao Delegators is not open right now\");\n        require(votingHashOfDaoMembersPerEpoch[msg.sender][currentEpoch] ==\n            keccak256(abi.encodePacked(password, daoDelegatorToVoteFor)), \"Wrong approval password or delegator\");\n        require(subscribedForDaoDelegator[daoDelegatorToVoteFor], \"Can only vote for active dao delegator subscriber\");\n        require(isEpochDaoMember[daoDelegatorToVoteFor][currentEpoch], \"Can only vote delegator that is active dao member\");\n        require(!hasApprovedForDaoDelegatorPerEpoch[msg.sender][currentEpoch], \"Cannot approve vote again\");\n\n        hasApprovedForDaoDelegatorPerEpoch[msg.sender][currentEpoch] = true;\n\n        if (!bannedDelegator[addressToId[daoDelegatorToVoteFor]][currentEpoch.add(1)]) {\n            uint256 votesForSubscriber = daoDelegatorsListForUpcomingEpoch.nodes[addressToId[daoDelegatorToVoteFor]].value;\n\n            if(votesForSubscriber != 0) {\n                daoDelegatorsListForUpcomingEpoch.removeNode(addressToId[daoDelegatorToVoteFor]);\n            }\n\n            daoDelegatorsListForUpcomingEpoch.addNodeDecrement(votesForSubscriber.add(1), addressToId[daoDelegatorToVoteFor]);\n        }\n    }\n\n    function claimDaoDelegation()\n    external\n    checkCronjob()\n    {\n        require(votingStatusForDaoDelegators >= VotingStatusDelegators.CLAIM_DELEGATION, \"Claiming Dao Delegation is not open right now\");\n        uint256 currentPosition = daoDelegatorsListForUpcomingEpoch.getPositionForId(addressToId[msg.sender]);\n\n        require(currentPosition > 0 && currentPosition <=\n            amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch.add(1)], \"Not eligible to become dao delegator\");\n\n        daoDelegatorsListForUpcomingEpoch.removeNode(addressToId[msg.sender]);\n        amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch.add(1)] =\n            amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch.add(1)].sub(1);\n\n        isEpochDaoDelegator[msg.sender][currentEpoch.add(1)] = true;\n\n        epochDaoDelegators[currentEpoch.add(1)].addNode(addressToId[msg.sender]);\n    }\n\n    function claimDaoSubstituteDelegation()\n    external\n    checkCronjob()\n    {\n        require(amountOfSubstitutesRequested[currentEpoch] > 0, \"No substitutes requested\");\n        uint256 currentPosition = daoSubstituteDelegatorsListForCurrentEpoch.getPositionForId(addressToId[msg.sender]);\n\n        require(currentPosition > 0 && currentPosition <=\n            amountOfEpochDaoDelegatorsNeededPerEpoch[currentEpoch], \"Not eligible to become dao delegator substitute\");\n\n        amountOfSubstitutesRequested[currentEpoch] = amountOfSubstitutesRequested[currentEpoch].sub(1);\n        epochDaoDelegators[currentEpoch].addNode(addressToId[msg.sender]);\n        isEpochDaoDelegator[msg.sender][currentEpoch] = true;\n\n        addSubstituteToAllActiveRequests(addressToId[msg.sender], currentEpoch);\n    }\n\n    function isDaoAssociated(address account, uint256 epoch)\n    external\n    view\n    returns(bool, bool, uint256, uint256)\n    {\n        return (\n            isEpochDaoMember[account][epoch],\n            isEpochDaoDelegator[account][epoch],\n            epochDaoMembers[epoch].getSize(),\n            epochDaoDelegators[epoch].getSize()\n        );\n    }\n}\n"
    },
    "contracts/governance/SuperGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"./DaoCronjob.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @notice Responsible for govern AllianceBlock's ecosystem\n */\ncontract SuperGovernance is OwnableUpgradeable, DaoCronjob {\n    using SafeMath for uint256;\n\n    function setRegistryAndStaking(\n        address registryAddress_,\n        address stakingAddress_\n    )\n    external\n    onlyOwner()\n    {\n        require(address(registry) == address(0), \"Cannot initialize second time\");\n        registry = IRegistry(registryAddress_);\n        staking = IStaking(stakingAddress_);\n\n        emit InitGovernance(registryAddress_, stakingAddress_, msg.sender);\n    }\n\n    function superVoteForRequest(\n        uint256 requestId,\n        bool decision\n    )\n    external\n    checkCronjob()\n    {\n        require(msg.sender == superDelegator, \"Only super delegator can call this function\");\n        require(currentEpoch <= 1, \"Super delegating works only till first epoch\");\n\n        if(approvalRequests[requestId].isMilestone) {\n            registry.decideForMilestone(approvalRequests[requestId].loanId, decision);\n        } else {\n            registry.decideForLoan(approvalRequests[requestId].loanId, decision);\n        }\n\n        if(decision) {\n            approvalRequests[requestId].approvalsProvided = approvalRequests[requestId].approvalsProvided.add(1);\n            approvalRequests[requestId].isApproved = true;\n        }\n\n        emit VotedForRequest(approvalRequests[requestId].loanId, requestId, decision, msg.sender);\n    }\n\n    function openDaoMembershipSubscriptions()\n    external\n    onlyOwner()\n    {\n        votingStatusForDaoMembers = VotingStatusMembers.PRE_STATE;\n    }\n\n    function openDaoMembershipVoting()\n    external\n    onlyOwner()\n    {\n        votingStatusForDaoMembers = VotingStatusMembers.VOTING;\n    }\n\n    function openDaoDelegatingSubscriptions(\n        uint256 amountOfDaoMembers_,\n        uint256 daoClaimingDuration_,\n        uint256 daoLateClaimingDuration_\n    )\n    external\n    onlyOwner()\n    {\n        updatableVariables[keccak256(abi.encode(\"amountOfDaoMembers\"))] = amountOfDaoMembers_;\n        updatableVariables[keccak256(abi.encode(\"daoClaimingDuration\"))] = daoClaimingDuration_;\n        updatableVariables[keccak256(abi.encode(\"daoLateClaimingDuration\"))] = daoLateClaimingDuration_;\n\n        votingStatusForDaoMembers = VotingStatusMembers.CLAIM_MEMBERSHIP;\n\n        addCronjob(CronjobType.DAO_MEMBERSHIP_VOTING, block.timestamp.add(daoClaimingDuration_), 0);\n\n        amountOfEpochDaoMembersNeededPerEpoch[currentEpoch.add(1)] = amountOfDaoMembers_;\n    }\n\n    function openDaoDelegatingVoting()\n    external\n    onlyOwner()\n    {\n        votingStatusForDaoDelegators = VotingStatusDelegators.VOTING;\n    }\n\n    function openDaoDelegating(\n        uint256 amountOfDaoDelegators_,\n        uint256 daoMembershipVotingDuration_,\n        uint256 daoDelegationVotingDuration_,\n        uint256 daoDelegationApprovalDuration_,\n        uint256 daoDelegationSubstituteClaimDuration_\n    )\n    external\n    onlyOwner()\n    {\n        updatableVariables[keccak256(abi.encode(\"amountOfDaoDelegators\"))] = amountOfDaoDelegators_;\n        updatableVariables[keccak256(abi.encode(\"daoMembershipVotingDuration\"))] = daoMembershipVotingDuration_;\n        updatableVariables[keccak256(abi.encode(\"daoDelegationVotingDuration\"))] = daoDelegationVotingDuration_;\n        updatableVariables[keccak256(abi.encode(\"daoDelegationApprovalDuration\"))] = daoDelegationApprovalDuration_;\n        updatableVariables[keccak256(abi.encode(\"daoDelegationSubstituteClaimDuration\"))] = daoDelegationSubstituteClaimDuration_;\n\n        votingStatusForDaoDelegators = VotingStatusDelegators.APPROVE_VOTING;\n\n        addCronjob(CronjobType.DAO_DELEGATORS_VOTING, block.timestamp.add(daoDelegationApprovalDuration_), 0);\n\n        uint256 timestampToOpenDaoMembershipVoting =\n            block.timestamp.add(daoDelegationApprovalDuration_).add(\n            updatableVariables[keccak256(abi.encode(\"daoClaimingDuration\"))]).add(\n            updatableVariables[keccak256(abi.encode(\"daoLateClaimingDuration\"))]);\n\n        addCronjob(CronjobType.DAO_MEMBERSHIP_VOTING, timestampToOpenDaoMembershipVoting, 0);\n    }\n}\n"
    },
    "contracts/mocks/Tests/GovernanceV2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"../../Governance.sol\";\n\n/**\n * @title AllianceBlock Governance contract\n * @dev WARNING Only for testing purposes, we added a couple of new methods and storage variables to check contract upgrade works fine\n * @notice Responsible for governing AllianceBlock's ecosystem\n */\ncontract GovernanceV2Test is Governance {\n    uint256 public foo;\n    uint256 public bar;\n\n    function getSomething1() public view returns (uint256) {\n        return 1;\n    }\n\n    function getSomething2() public view returns (uint256) {\n        return 2;\n    }\n}\n"
    },
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./registry/PersonalLoan.sol\";\nimport \"./registry/ProjectLoan.sol\";\nimport \"./registry/Investment.sol\";\nimport \"./libs/TokenFormat.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title AllianceBlock Registry contract\n * @notice Responsible for loan transactions.\n */\ncontract Registry is Initializable, Investment, PersonalLoan, ProjectLoan, OwnableUpgradeable {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    // Events\n    event LoanPartitionsPurchased(\n        uint256 indexed loanId,\n        uint256 partitionsToPurchase,\n        address lender\n    );\n    event LoanStarted(\n        uint256 indexed loanId,\n        LoanLibrary.LoanType indexed loanType\n    );\n    event LoanApproved(\n        uint256 indexed loanId,\n        LoanLibrary.LoanType indexed loanType\n    );\n    event LoanRejected(\n        uint256 indexed loanId,\n        LoanLibrary.LoanType indexed loanType\n    );\n    event LoanChallenged(\n        uint256 indexed loanId,\n        LoanLibrary.LoanType indexed loanType,\n        address user\n    );\n    event PaymentReceived(\n        uint256 indexed loanId,\n        uint256 amountOfTokens,\n        uint256 indexed generation,\n        bool indexed onProjectTokens,\n        address user\n    );\n    event PaymentExecuted(\n        uint256 indexed loanId,\n        LoanLibrary.LoanType indexed loanType,\n        address indexed seeker\n    );\n\n    /**\n     * @dev Constructor of the contract.\n     */\n    function initialize(\n        address escrowAddress,\n        address governanceAddress_,\n        address lendingToken_,\n        address mainNFT_,\n        address fundingNFT_,\n        uint256 baseAmountForEachPartition_,\n        uint256 minimumInterestPercentage_,\n        uint256 maxMilestones_,\n        uint256 milestoneExtensionInterval_,\n        uint256 vestingBatches_,\n        uint256 vestingTimeInterval_,\n        uint256 fundingTimeInterval_\n    ) public initializer {\n        __Ownable_init();\n        escrow = IEscrow(escrowAddress);\n        baseAmountForEachPartition = baseAmountForEachPartition_;\n        governance = IGovernance(governanceAddress_);\n        lendingToken = IERC20(lendingToken_);\n        minimumInterestPercentage = minimumInterestPercentage_;\n        mainNFT = IERC721Mint(mainNFT_);\n        fundingNFT = IERC1155Mint(fundingNFT_);\n        maxMilestones = maxMilestones_;\n        milestoneExtensionInterval = milestoneExtensionInterval_;\n        vestingBatches = vestingBatches_;\n        vestingTimeInterval = vestingTimeInterval_;\n        fundingTimeInterval = fundingTimeInterval_;\n    }\n\n    /**\n     * @dev This function is called by the owner to initialize the investment type.\n     * @param reputationalAlbt The address of the rALBT contract.\n     * @param totalTicketsPerRun_ The amount of tickets that will be provided from each run of the lottery.\n     * @param rAlbtPerLotteryNumber_ The amount of rALBT needed to allocate one lucky number.\n     * @param blocksLockedForReputation_ The amount of blocks needed for a ticket to be locked,\n     *        so as investor to get 1 rALBT for locking it.\n     */\n    function initializeInvestment(\n        address reputationalAlbt,\n        uint256 totalTicketsPerRun_,\n        uint256 rAlbtPerLotteryNumber_,\n        uint256 blocksLockedForReputation_,\n        uint256 lotteryNumbersForImmediateTicket_\n    )\n    external\n    onlyOwner()\n    {\n        require(totalTicketsPerRun == 0, \"Cannot initialize twice\");\n        rALBT = IERC20(reputationalAlbt);\n        totalTicketsPerRun = totalTicketsPerRun_;\n        rAlbtPerLotteryNumber = rAlbtPerLotteryNumber_;\n        blocksLockedForReputation = blocksLockedForReputation_;\n        lotteryNumbersForImmediateTicket = lotteryNumbersForImmediateTicket_;\n    }\n\n    /**\n     * @dev This function is called by governance to approve or reject a loan request.\n     * @param loanId The id of the loan.\n     * @param decision The decision of the governance. [true -> approved] [false -> rejected]\n     */\n    function decideForLoan(uint256 loanId, bool decision)\n        external\n        onlyGovernance()\n    {\n        if (decision) _approveLoan(loanId);\n        else _rejectLoan(loanId);\n    }\n\n    /**\n     * @dev This function is called by the lenders to fund a loan.\n     * @param loanId The id of the loan.\n     * @param partitionsToPurchase The amount of ERC1155 tokens (which represent partitions of the loan) to be purchased.\n     */\n    function fundLoan(uint256 loanId, uint256 partitionsToPurchase)\n        external\n        onlyActivelyFundedLoan(loanId)\n    {\n        require(\n            partitionsToPurchase <=\n                loanDetails[loanId].totalPartitions.sub(\n                    loanDetails[loanId].partitionsPurchased\n                ),\n            \"Not enough partitions left for purchase\"\n        );\n\n        if (loanStatus[loanId] == LoanLibrary.LoanStatus.APPROVED) {\n            loanStatus[loanId] = LoanLibrary.LoanStatus.FUNDING;\n        }\n\n        IERC20(lendingToken).transferFrom(\n            msg.sender,\n            address(escrow),\n            partitionsToPurchase.mul(baseAmountForEachPartition)\n        );\n\n        if (loanDetails[loanId].loanType == LoanLibrary.LoanType.PERSONAL) {\n            escrow.transferFundingNFT(loanId, partitionsToPurchase, msg.sender);\n        } else {\n            _transferFundingNFTToProjectFunder(\n                loanId,\n                partitionsToPurchase,\n                msg.sender\n            );\n        }\n\n        loanDetails[loanId].partitionsPurchased = loanDetails[loanId]\n            .partitionsPurchased\n            .add(partitionsToPurchase);\n\n        emit LoanPartitionsPurchased(loanId, partitionsToPurchase, msg.sender);\n        if (\n            loanDetails[loanId].partitionsPurchased ==\n            loanDetails[loanId].totalPartitions\n        ) {\n            _startLoan(loanId);\n        }\n    }\n\n    /**\n     * @dev This function is called by the seeker to return part of or whole owed amount for a loan (depending on agreement).\n     * @param loanId The id of the loan.\n     */\n    function executePayment(uint256 loanId) external onlySeeker(loanId) {\n        if (loanDetails[loanId].loanType == LoanLibrary.LoanType.PERSONAL) {\n            _executePersonalLoanPayment(loanId);\n        } else {\n            _executeProjectLoanPayment(loanId);\n        }\n        emit PaymentExecuted(loanId, loanDetails[loanId].loanType, msg.sender);\n    }\n\n    /**\n     * @dev This function is called by ERC1155 holders to receive a payment (after seeker has repaid part of loan).\n     * @param tokenId The token id of the ERC1155 tokens, which is eligible for the payment.\n     * @param amountOfTokens The amount of NFT tokens to receive payment for.\n     * @param onProjectTokens Only used in project loans. [true -> repayment in project token] [false -> repayment in lending token]\n     */\n    function receivePayment(\n        uint256 tokenId,\n        uint256 amountOfTokens,\n        bool onProjectTokens\n    ) external onlyEnoughERC1155Balance(tokenId, amountOfTokens) {\n        (uint256 generation, uint256 loanId) = tokenId.formatTokenId();\n        if (loanDetails[loanId].loanType == LoanLibrary.LoanType.PERSONAL) {\n            _receivePersonalLoanPayment(loanId, generation, amountOfTokens);\n        } else {\n            _receiveProjectLoanPayment(\n                loanId,\n                generation,\n                amountOfTokens,\n                onProjectTokens\n            );\n        }\n        emit PaymentReceived(\n            loanId,\n            amountOfTokens,\n            generation,\n            onProjectTokens,\n            msg.sender\n        );\n    }\n\n    /**\n     * @dev This function is called by governance to start the lottery phase for an investment.\n     * @param investmentId The id of the investment.\n     */\n    function startLotteryPhase(uint256 investmentId)\n        external\n        onlyGovernance()\n    {\n        _startLoan(investmentId);\n    }\n\n    /**\n     * @dev Through this function any address can challenge a loan in case of rules breaking by the borrower.\n            If challenging succeeds it can end up to either small penalty or whole collateral loss.\n     * @param loanId The id of the loan.\n     */\n    function challengeLoan(uint256 loanId)\n        external\n        onlyActiveLoan(loanId)\n        onlyAfterDeadlineReached(loanId)\n    {\n        if (loanDetails[loanId].loanType == LoanLibrary.LoanType.PERSONAL)\n            _challengePersonalLoan(loanId);\n        else _challengeProjectLoan(loanId);\n        emit LoanChallenged(loanId, loanDetails[loanId].loanType, msg.sender);\n    }\n\n    function _approveLoan(uint256 loanId_) internal {\n        loanStatus[loanId_] = LoanLibrary.LoanStatus.APPROVED;\n        loanDetails[loanId_].approvalDate = block.timestamp;\n        fundingNFT.unpauseTokenTransfer(loanId_); //UnPause trades for ERC1155s with the specific loan ID.\n        if (loanDetails[loanId_].loanType == LoanLibrary.LoanType.INVESTMENT) {\n            ticketsRemaining[loanId_] = loanDetails[loanId_].totalPartitions;\n            governance.storeInvestmentTriggering(loanId_);\n        }\n        emit LoanApproved(loanId_, loanDetails[loanId_].loanType);\n    }\n\n    function _rejectLoan(uint256 loanId_) internal {\n        loanStatus[loanId_] = LoanLibrary.LoanStatus.REJECTED;\n        escrow.transferCollateralToken(\n            loanDetails[loanId_].collateralToken,\n            loanSeeker[loanId_],\n            loanDetails[loanId_].collateralAmount\n        );\n        emit LoanRejected(loanId_, loanDetails[loanId_].loanType);\n    }\n\n    function _startLoan(uint256 loanId_) internal {\n        loanStatus[loanId_] = LoanLibrary.LoanStatus.STARTED;\n        loanDetails[loanId_].startingDate = block.timestamp;\n\n        if (loanDetails[loanId_].loanType == LoanLibrary.LoanType.PERSONAL)\n            _startPersonalLoan(loanId_);\n        else if (loanDetails[loanId_].loanType == LoanLibrary.LoanType.PROJECT)\n            _startProjectLoan(loanId_);\n        emit LoanStarted(loanId_, loanDetails[loanId_].loanType);\n    }\n\n    /**\n     * @dev This helper function provides a single point for querying the Loan metadata\n     * @param loanId The id of the loan.\n     */\n    function getLoanMetadata(uint256 loanId)\n        public\n        view\n        returns (\n            LoanLibrary.LoanDetails memory, // the loanDetails\n            LoanLibrary.LoanStatus, // the loanStatus\n            address, // the loanSeeker,\n            LoanLibrary.RepaymentBatchType // the repaymentBatchType\n        )\n    {\n        return (\n            loanDetails[loanId],\n            loanStatus[loanId],\n            loanSeeker[loanId],\n            personalLoanPayments[loanId].repaymentBatchType\n        );\n    }\n}\n"
    },
    "contracts/registry/PersonalLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./LoanDetails.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title AllianceBlock PersonalLoan contract\n * @notice Functionality for Personal Loan.\n */\ncontract PersonalLoan is LoanDetails {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    // Events\n    event PersonalLoanRequested(\n        uint256 indexed loanId,\n        address indexed user,\n        uint256 amount\n    );\n\n    /**\n     * @dev This function is used for potential seekers to request a personal loan.\n     * @param amountRequested The lending amount seeker is looking to get.\n     * @param collateralToken The token that will be used by the seeker as collateral.\n     * @param collateralAmount The amount of tokens that will be used by the seeker as collateral.\n     * @param totalAmountOfBatches The amount of batches in which loan will be repaid.\n     * @param interestPercentage The interest percentage that will be obtained after whole repayment.\n     * @param batchTimeInterval The time interval between repayment batches.\n     * @param extraInfo The ipfs hash where more specific details for loan request are stored.\n     * @param repaymentBatchType The way the repayment in each batch will happen. [ONLY_INTEREST or INTEREST_PLUS_NOMINAL]\n     *        ONLY_INTEREST means that in every batch part of the interest will be repaid and whole nominal in the last batch.\n     *        INTEREST_PLUS_NOMINAL means that in every batch part of the interest and nominal will be repaid.\n     */\n    function requestPersonalLoan(\n        uint256 amountRequested,\n        address collateralToken,\n        uint256 collateralAmount,\n        uint256 totalAmountOfBatches,\n        uint256 interestPercentage,\n        uint256 batchTimeInterval,\n        string memory extraInfo,\n        LoanLibrary.RepaymentBatchType repaymentBatchType\n    ) external {\n        require(uint256(repaymentBatchType) <= 1, \"Wrong repayment batch type\");\n        require(\n            amountRequested.mod(baseAmountForEachPartition) == 0,\n            \"Requested Amount must be a multiplier of base amount\"\n        );\n\n        _storeLoanDetails(\n            LoanLibrary.LoanType.PERSONAL,\n            amountRequested,\n            collateralToken,\n            collateralAmount,\n            interestPercentage,\n            extraInfo\n        );\n\n        _storePersonalLoanPayments(\n            totalAmountOfBatches,\n            batchTimeInterval,\n            repaymentBatchType\n        );\n\n        IERC20(collateralToken).transferFrom(\n            msg.sender,\n            address(escrow),\n            collateralAmount\n        );\n\n        // TODO - Mint Correctly And Burn on Settlement\n        // mainNFT.mint(address(escrow));\n        fundingNFT.mintGen0(\n            address(escrow),\n            loanDetails[totalLoans].totalPartitions,\n            totalLoans\n        );\n\n        fundingNFT.pauseTokenTransfer(totalLoans); //Pause trades for ERC1155s with the specific loan ID.\n\n        governance.requestApproval(totalLoans, false, 0);\n\n        emit PersonalLoanRequested(totalLoans, msg.sender, amountRequested);\n\n        totalLoans = totalLoans.add(1);\n    }\n\n    function _storePersonalLoanPayments(\n        uint256 totalAmountOfBatches_,\n        uint256 batchTimeInterval_,\n        LoanLibrary.RepaymentBatchType repaymentBatchType_\n    ) internal {\n        // Calculate repayment of seeker for each batch.\n        if (\n            repaymentBatchType_ == LoanLibrary.RepaymentBatchType.ONLY_INTEREST\n        ) {\n            personalLoanPayments[totalLoans].amountEachBatch = loanDetails[\n                totalLoans\n            ]\n                .totalInterest\n                .div(totalAmountOfBatches_);\n        } else {\n            personalLoanPayments[totalLoans].amountEachBatch = (\n                loanDetails[totalLoans].totalInterest.add(\n                    loanDetails[totalLoans].lendingAmount\n                )\n            )\n                .div(totalAmountOfBatches_);\n        }\n\n        personalLoanPayments[totalLoans]\n            .totalAmountOfBatches = totalAmountOfBatches_;\n        personalLoanPayments[totalLoans]\n            .timeIntervalBetweenBatches = batchTimeInterval_;\n        personalLoanPayments[totalLoans]\n            .repaymentBatchType = repaymentBatchType_;\n    }\n\n    function _startPersonalLoan(uint256 loanId_) internal {\n        personalLoanPayments[loanId_].batchStartingTimestamp = block.timestamp;\n        personalLoanPayments[loanId_].batchDeadlineTimestamp = block\n            .timestamp\n            .add(personalLoanPayments[loanId_].timeIntervalBetweenBatches);\n\n        escrow.transferLendingToken(\n            loanSeeker[loanId_],\n            loanDetails[loanId_].lendingAmount\n        );\n    }\n\n    function _challengePersonalLoan(uint256 loanId_) internal {\n        personalLoanPayments[loanId_].batchesSkipped = personalLoanPayments[\n            loanId_\n        ]\n            .batchesSkipped\n            .add(1);\n\n        if (personalLoanPayments[loanId_].batchesSkipped > 1) {\n            loanStatus[loanId_] == LoanLibrary.LoanStatus.DEFAULT;\n            // TODO - SPECIFY DEFAULT\n        } else {\n            personalLoanPayments[loanId_]\n                .batchDeadlineTimestamp = personalLoanPayments[loanId_]\n                .batchDeadlineTimestamp\n                .add(personalLoanPayments[loanId_].timeIntervalBetweenBatches);\n        }\n    }\n\n    function _executePersonalLoanPayment(uint256 loanId_)\n        internal\n        onlyBetweenBatchTimeframe(loanId_)\n        onlyActiveLoan(loanId_)\n    {\n        //if interest + nominal\n        if (\n            personalLoanPayments[loanId_].repaymentBatchType ==\n            LoanLibrary.RepaymentBatchType.INTEREST_PLUS_NOMINAL\n        ) {\n            _transferPersonalLoanPayment(\n                loanId_,\n                personalLoanPayments[loanId_].amountEachBatch\n            );\n        } else {\n            //if interest only\n            _executePersonalLoanInterestOnlyPayment(loanId_);\n        }\n    }\n\n    function _executePersonalLoanInterestOnlyPayment(uint256 loanId_) internal {\n        uint256 amount;\n        //if last batch\n        if (\n            personalLoanPayments[loanId_].batchesPaid.add(1) ==\n            personalLoanPayments[loanId_].totalAmountOfBatches\n        ) {\n            amount = personalLoanPayments[loanId_].amountEachBatch.add(\n                loanDetails[loanId_].lendingAmount\n            );\n        } else {\n            //any other batch\n            amount = personalLoanPayments[loanId_].amountEachBatch;\n        }\n        _transferPersonalLoanPayment(loanId_, amount);\n    }\n\n    function _transferPersonalLoanPayment(uint256 loanId_, uint256 amount)\n        internal\n    {\n        IERC20(lendingToken).transferFrom(msg.sender, address(escrow), amount);\n\n        personalLoanPayments[loanId_].batchesPaid = personalLoanPayments[\n            loanId_\n        ]\n            .batchesPaid\n            .add(1);\n\n        if (\n            personalLoanPayments[loanId_].batchesPaid ==\n            personalLoanPayments[loanId_].totalAmountOfBatches\n        ) {\n            loanStatus[loanId_] = LoanLibrary.LoanStatus.SETTLED;\n            escrow.transferCollateralToken(\n                loanDetails[loanId_].collateralToken,\n                loanSeeker[loanId_],\n                loanDetails[loanId_].collateralAmount\n            );\n        } else {\n            personalLoanPayments[loanId_]\n                .batchStartingTimestamp = personalLoanPayments[loanId_]\n                .batchDeadlineTimestamp;\n            personalLoanPayments[loanId_]\n                .batchDeadlineTimestamp = personalLoanPayments[loanId_]\n                .batchStartingTimestamp\n                .add(personalLoanPayments[loanId_].timeIntervalBetweenBatches);\n        }\n    }\n\n    function _receivePersonalLoanPayment(\n        uint256 loanId_,\n        uint256 generation_,\n        uint256 amountOfTokens_\n    ) internal onlySettledLoan(loanId_) {\n        uint256 batchesToBePaid =\n            generation_.sub(personalLoanPayments[loanId_].batchesPaid);\n        require(batchesToBePaid > 0, \"Not eligible for payment\");\n\n        uint256 amountToBePaid =\n            personalLoanPayments[loanId_]\n                .amountEachBatch\n                .mul(amountOfTokens_)\n                .mul(batchesToBePaid)\n                .div(loanDetails[loanId_].totalPartitions);\n\n        if (loanStatus[loanId_] == LoanLibrary.LoanStatus.SETTLED) {\n            if (\n                personalLoanPayments[loanId_].repaymentBatchType ==\n                LoanLibrary.RepaymentBatchType.ONLY_INTEREST\n            ) {\n                amountToBePaid = amountToBePaid.add(\n                    loanDetails[loanId_].lendingAmount.mul(amountOfTokens_).div(\n                        loanDetails[loanId_].totalPartitions\n                    )\n                );\n            }\n\n            fundingNFT.burn(\n                msg.sender,\n                generation_.getTokenId(loanId_),\n                amountOfTokens_\n            );\n        } else {\n            fundingNFT.increaseGenerations(\n                generation_.getTokenId(loanId_),\n                msg.sender,\n                amountOfTokens_,\n                batchesToBePaid\n            );\n        }\n\n        escrow.transferLendingToken(msg.sender, amountToBePaid);\n    }\n}\n"
    },
    "contracts/registry/ProjectLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./LoanDetails.sol\";\nimport \"../libs/TokenFormat.sol\";\n\n/**\n * @title AllianceBlock ProjectLoan contract\n * @notice Functionality for Project Loan.\n */\ncontract ProjectLoan is LoanDetails {\n    using SafeMath for uint256;\n    using TokenFormat for uint256;\n\n    // Events\n    event ProjectLoanRequested(\n        uint256 indexed loanId,\n        address indexed user,\n        uint256 amount\n    );\n    event ProjectLoanMilestoneApprovalRequested(\n        uint256 indexed loanId,\n        uint256 milestoneNumber\n    );\n    event ProjectLoanMilestoneDecided(uint256 indexed loanId, bool decision);\n    event ProjectTokenPaymentReceived(\n        uint256 indexed loanId,\n        address indexed user,\n        uint256 amountOfProjectTokens,\n        uint256 discountedPrice\n    );\n\n    /**\n     * @dev This function is used for potential borrowing project to request a loan.\n     * @param amountRequestedPerMilestone The lending amounts project is looking to get for each milestone.\n     * @param collateralToken The token that will be used by the proect as collateral.\n     * @param collateralAmount The amount of tokens that will be used by the project as collateral.\n     * @param projectTokenPrice The price the project wants to sell its token for.\n     * @param interestPercentage The interest percentage that will be obtained after whole repayment.\n     * @param discountPerMillion The discount given on the token price when funders claim repayment in project tokens.\n     * @param totalMilestones The total amount of Milestones project is requesting funds for.\n     * @param milestoneDurations The duration of each Milestone.\n     * @param paymentTimeInterval The time interval between the last milestone delivery by the project and\n     * the repayment of the loan by the project.\n     * @param extraInfo The ipfs hash where more specific details for loan request are stored.\n     */\n    function requestProjectLoan(\n        uint256[] calldata amountRequestedPerMilestone,\n        address collateralToken,\n        uint256 collateralAmount,\n        uint256 projectTokenPrice,\n        uint256 interestPercentage,\n        uint256 discountPerMillion,\n        uint256 totalMilestones,\n        uint256[] calldata milestoneDurations,\n        uint256 paymentTimeInterval,\n        string memory extraInfo\n    ) external onlyAcceptedNumberOfMilestones(totalMilestones) {\n        require(\n            (amountRequestedPerMilestone.length == totalMilestones) &&\n                (milestoneDurations.length == totalMilestones),\n            \"Total milestones requested should coincide with requested amounts and durations\"\n        );\n\n        uint256 totalAmountRequested =\n            _storeMilestoneDetailsAndGetTotalAmount(\n                amountRequestedPerMilestone,\n                milestoneDurations,\n                totalMilestones\n            );\n\n        _storeLoanDetails(\n            LoanLibrary.LoanType.PROJECT,\n            totalAmountRequested,\n            collateralToken,\n            collateralAmount,\n            interestPercentage,\n            extraInfo\n        );\n\n        _storeProjectLoanPayments(\n            discountPerMillion,\n            projectTokenPrice,\n            totalMilestones,\n            paymentTimeInterval\n        );\n\n        IERC20(collateralToken).transferFrom(\n            msg.sender,\n            address(escrow),\n            collateralAmount\n        );\n\n        // TODO - Mint Correctly And Burn on Settlement\n        // mainNFT.mint(address(escrow));\n        fundingNFT.mintOfGen(\n            address(escrow),\n            loanDetails[totalLoans].totalPartitions,\n            totalMilestones.sub(1),\n            totalLoans\n        );\n\n        fundingNFT.pauseTokenTransfer(totalLoans); //Pause trades for ERC1155s with the specific loan ID.\n\n        governance.requestApproval(totalLoans, false, 0);\n\n        emit ProjectLoanRequested(totalLoans, msg.sender, totalAmountRequested);\n\n        totalLoans = totalLoans.add(1);\n    }\n\n    /**\n     * @dev This function is used by the project to apply a milestone for a specific loan.\n     * @param loanId The id of the loan.\n     */\n    function applyMilestone(uint256 loanId)\n        external\n        onlySeeker(loanId)\n        onlyActiveLoan(loanId)\n        onlyProjectLoan(loanId)\n        onlyBetweenMilestoneTimeframe(loanId)\n    {\n        loanStatus[loanId] = LoanLibrary.LoanStatus.AWAITING_MILESTONE_APPROVAL;\n        governance.requestApproval(\n            loanId,\n            true,\n            projectLoanPayments[loanId].milestonesDelivered\n        );\n\n        emit ProjectLoanMilestoneApprovalRequested(\n            loanId,\n            projectLoanPayments[loanId].milestonesDelivered\n        );\n    }\n\n    /**\n     * @dev This function is called by governance to approve or reject an applied milestone's request.\n     * @param loanId The id of the loan.\n     * @param decision The decision of the governance. [true -> approved] [false -> rejected]\n     */\n    function decideForMilestone(uint256 loanId, bool decision)\n        external\n        onlyGovernance()\n        onlyWhenAwaitingMilestoneApproval(loanId)\n        onlyProjectLoan(loanId)\n    {\n        if (decision) _approveMilestone(loanId);\n        else _rejectMilestone(loanId);\n\n        emit ProjectLoanMilestoneDecided(loanId, decision);\n    }\n\n    function _approveMilestone(uint256 loanId_) internal {\n        projectLoanPayments[loanId_].milestonesDelivered = projectLoanPayments[\n            loanId_\n        ]\n            .milestonesDelivered\n            .add(1);\n\n        // Milestones completed\n        if (\n            projectLoanPayments[loanId_].milestonesDelivered ==\n            projectLoanPayments[loanId_].totalMilestones\n        ) {\n            loanStatus[loanId_] = LoanLibrary.LoanStatus.AWAITING_REPAYMENT;\n            projectLoanPayments[loanId_].awaitingForRepaymentDate = block\n                .timestamp;\n            // Milestones missing\n        } else {\n            loanStatus[loanId_] = LoanLibrary\n                .LoanStatus\n                .AWAITING_MILESTONE_APPLICATION;\n            escrow.transferLendingToken(\n                loanSeeker[loanId_],\n                projectLoanPayments[loanId_].milestoneLendingAmount[\n                    projectLoanPayments[loanId_].milestonesDelivered\n                ]\n            );\n            projectLoanPayments[loanId_]\n                .currentMilestoneStartingTimestamp = block.timestamp;\n            projectLoanPayments[loanId_]\n                .currentMilestoneDeadlineTimestamp = block.timestamp.add(\n                projectLoanPayments[loanId_].milestoneDuration[\n                    projectLoanPayments[loanId_].milestonesDelivered\n                ]\n            );\n            // TODO: get real price from DEX, Oracle or user input\n            projectLoanPayments[loanId_].milestoneProjectTokenPrice[\n                projectLoanPayments[loanId_].milestonesDelivered\n            ] = _getMockedPriceForMilestone(0);\n        }\n    }\n\n    function _rejectMilestone(uint256 loanId_) internal {\n        loanStatus[loanId_] == LoanLibrary.LoanStatus.STARTED;\n        if (\n            projectLoanPayments[loanId_].currentMilestoneDeadlineTimestamp <=\n            block.timestamp\n        ) {\n            _challengeProjectLoan(loanId_);\n        }\n    }\n\n    function _storeProjectLoanPayments(\n        uint256 discountPerMillion_,\n        uint256 projectTokenPrice_,\n        uint256 totalMilestones_,\n        uint256 paymentTimeInterval_\n    ) internal {\n        projectLoanPayments[totalLoans]\n            .discountPerMillion = discountPerMillion_;\n        projectLoanPayments[totalLoans].milestoneProjectTokenPrice[\n            0\n        ] = projectTokenPrice_;\n        projectLoanPayments[totalLoans].totalMilestones = totalMilestones_;\n        projectLoanPayments[totalLoans]\n            .paymentTimeInterval = paymentTimeInterval_;\n    }\n\n    function _storeMilestoneDetailsAndGetTotalAmount(\n        uint256[] memory amountRequestedPerMilestone,\n        uint256[] memory milestoneDurations,\n        uint256 totalMilestones\n    ) internal returns (uint256 totalAmountRequested) {\n        for (uint256 i = 0; i < totalMilestones; i++) {\n            require(\n                amountRequestedPerMilestone[i].mod(\n                    baseAmountForEachPartition\n                ) == 0,\n                \"Requested milestone amounts must be multipliers of base amount\"\n            );\n            projectLoanPayments[totalLoans].milestoneLendingAmount[\n                i\n            ] = amountRequestedPerMilestone[i];\n            projectLoanPayments[totalLoans].milestoneDuration[\n                i\n            ] = milestoneDurations[i];\n\n            totalAmountRequested = totalAmountRequested.add(\n                amountRequestedPerMilestone[i]\n            );\n        }\n    }\n\n    function _startProjectLoan(uint256 loanId_) internal {\n        projectLoanPayments[loanId_].currentMilestoneStartingTimestamp = block\n            .timestamp;\n        projectLoanPayments[loanId_].currentMilestoneDeadlineTimestamp = block\n            .timestamp\n            .add(projectLoanPayments[loanId_].milestoneDuration[0]);\n\n        // For investments without real milestones (the only milestone is of 0 duration),\n        // the first and only milestone should be approved automatically so project tokens can be claimed\n        if (\n            projectLoanPayments[loanId_].totalMilestones == 1 &&\n            projectLoanPayments[loanId_].milestoneDuration[0] == 0\n        ) {\n            _approveMilestone(loanId_);\n        }\n\n        escrow.transferLendingToken(\n            loanSeeker[loanId_],\n            projectLoanPayments[loanId_].milestoneLendingAmount[0]\n        );\n    }\n\n    function _getMockedPriceForMilestone(uint256 milestone)\n        internal\n        returns (uint256 price)\n    {\n        price = milestone.add(1);\n    }\n\n    function _challengeProjectLoan(uint256 loanId_) internal {\n        projectLoanPayments[loanId_].milestonesExtended = projectLoanPayments[\n            loanId_\n        ]\n            .milestonesExtended\n            .add(1);\n\n        if (projectLoanPayments[loanId_].milestonesExtended > 1) {\n            loanStatus[loanId_] == LoanLibrary.LoanStatus.DEFAULT;\n            // TODO - SPECIFY DEFAULT\n        } else {\n            projectLoanPayments[loanId_]\n                .currentMilestoneDeadlineTimestamp = projectLoanPayments[\n                loanId_\n            ]\n                .currentMilestoneDeadlineTimestamp\n                .add(milestoneExtensionInterval);\n        }\n    }\n\n    function _transferFundingNFTToProjectFunder(\n        uint256 loanId_,\n        uint256 partitionsFunded_,\n        address funder_\n    ) internal {\n        uint256 tokenGeneration =\n            projectLoanPayments[loanId_].totalMilestones.sub(1);\n        uint256 tokenId = tokenGeneration.getTokenId(loanId_);\n        escrow.transferFundingNFT(tokenId, partitionsFunded_, funder_);\n        // Decrease the generation of a percentage of the tokens so they can already be converted in project tokens after every milestone instead of only being repaid at the end of the loan.\n        for (\n            uint256 i = 0;\n            i < projectLoanPayments[loanId_].totalMilestones.sub(1);\n            i++\n        ) {\n            uint256 partitionsToConvertAtMilestone =\n                partitionsFunded_\n                    .mul(projectLoanPayments[loanId_].milestoneLendingAmount[i])\n                    .div(loanDetails[loanId_].lendingAmount);\n\n            fundingNFT.decreaseGenerations(\n                tokenId,\n                funder_,\n                partitionsToConvertAtMilestone,\n                tokenGeneration.sub(i)\n            );\n        }\n    }\n\n    function _executeProjectLoanPayment(uint256 loanId_)\n        internal\n        onlyOnProjectRepayment(loanId_)\n    {\n        IERC20(lendingToken).transferFrom(\n            msg.sender,\n            address(escrow),\n            getAmountToBeRepaid(loanId_)\n        );\n        loanStatus[loanId_] = LoanLibrary.LoanStatus.SETTLED;\n        escrow.transferCollateralToken(\n            loanDetails[loanId_].collateralToken,\n            loanSeeker[loanId_],\n            loanDetails[loanId_].collateralAmount\n        );\n    }\n\n    function _receiveProjectLoanPayment(\n        uint256 loanId_,\n        uint256 generation_,\n        uint256 amountOfTokens_,\n        bool onProjectTokens_\n    ) internal {\n        if (onProjectTokens_) {\n            _receiveProjectTokenPayment(loanId_, amountOfTokens_);\n        } else {\n            _receiveLendingTokenPayment(loanId_, generation_, amountOfTokens_);\n        }\n    }\n\n    function _receiveLendingTokenPayment(\n        uint256 loanId_,\n        uint256 generation_,\n        uint256 amountOfTokens_\n    ) internal onlySettledLoan(loanId_) {\n        uint256 tokenId = generation_.getTokenId(loanId_);\n        require(\n            fundingNFT.balanceOf(msg.sender, tokenId) >= amountOfTokens_,\n            \"Insufficient Loan NFT Balance\"\n        );\n        uint256 amountToReceive =\n            getAmountToBeRepaid(loanId_).mul(amountOfTokens_).div(\n                loanDetails[loanId_].totalPartitions.sub(\n                    projectLoanPayments[loanId_].partitionsPaidInProjectTokens\n                )\n            );\n\n        fundingNFT.burn(msg.sender, tokenId, amountOfTokens_);\n        escrow.transferLendingToken(msg.sender, amountToReceive);\n    }\n\n    function _receiveProjectTokenPayment(\n        uint256 loanId_,\n        uint256 amountFundingNFT_\n    ) internal {\n        require(\n            getAvailableFundingNFTForConversion(loanId_, msg.sender) >=\n                amountFundingNFT_,\n            \"No funding NFT available for conversion to project tokens\"\n        );\n\n        uint256 amount =\n            getAmountOfProjectTokensToReceive(loanId_, amountFundingNFT_);\n\n        // Keep track of the partitions paid in project tokens to reduce them from the settlement amount after milestone delivery\n        projectLoanPayments[loanId_]\n            .partitionsPaidInProjectTokens = projectLoanPayments[loanId_]\n            .partitionsPaidInProjectTokens\n            .add(amountFundingNFT_);\n\n        // Burn the funding NFT used to claim the project tokens\n        _burnFundingNFTAmountOverGenerations(loanId_, amountFundingNFT_);\n\n        // Transfer the project tokens to the funder\n        escrow.transferCollateralToken(\n            loanDetails[loanId_].collateralToken,\n            msg.sender,\n            amount\n        );\n\n        emit ProjectTokenPaymentReceived(\n            loanId_,\n            msg.sender,\n            amount,\n            getDiscountedProjectTokenPrice(loanId_)\n        );\n    }\n\n    function _burnFundingNFTAmountOverGenerations(\n        uint256 loanId_,\n        uint256 amountFundingNFT_\n    ) internal {\n        uint256 totalFundingNFTToBurn = amountFundingNFT_;\n        for (\n            uint256 i = 0;\n            i < projectLoanPayments[loanId_].milestonesDelivered &&\n                totalFundingNFTToBurn > 0;\n            i++\n        ) {\n            uint256 fundingNFTBalance =\n                balanceOfFundingNFTGeneration(loanId_, i, msg.sender);\n            uint256 fundingNFTToBurn =\n                fundingNFTBalance > totalFundingNFTToBurn\n                    ? totalFundingNFTToBurn\n                    : fundingNFTBalance;\n\n            fundingNFT.burn(\n                msg.sender,\n                i.getTokenId(loanId_),\n                fundingNFTToBurn\n            );\n\n            totalFundingNFTToBurn = totalFundingNFTToBurn.sub(fundingNFTToBurn);\n        }\n    }\n\n    // GETTERS\n    function getMilestonesInfo(uint256 loanId_, uint256 milestone_)\n        public\n        view\n        returns (uint256 amount, uint256 timestamp)\n    {\n        amount = projectLoanPayments[loanId_].milestoneLendingAmount[\n            milestone_\n        ];\n        timestamp = projectLoanPayments[loanId_].milestoneDuration[milestone_];\n    }\n\n    /**\n     * @dev getAmountToBeRepaid is a function to obtain the amount that should be paid to settle the loan\n     * taking into account the amount paid back with project tokens and the interest percentage.\n     * @param loanId The id of the loan to get the amount to be repaid from.\n     * @return amount The total amount to be paid in lending tokens to settle the loan.\n     */\n    function getAmountToBeRepaid(uint256 loanId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // Substract the partitions already paid in project tokens from the lending amount to pay back\n        uint256 lendingTokenAmount =\n            loanDetails[loanId].lendingAmount.sub(\n                projectLoanPayments[loanId].partitionsPaidInProjectTokens.mul(\n                    baseAmountForEachPartition\n                )\n            );\n        // Calculate the interest only over what is left to pay in the lending token\n        uint256 interest =\n            lendingTokenAmount.mul(loanDetails[loanId].interestPercentage).div(\n                100\n            );\n        amount = lendingTokenAmount.add(interest);\n    }\n\n    /**\n     * @dev getTotalInterest is a function to obtain the total amount of interest to pay back\n     * taking into account the interest free amount paid back with project tokens and the interest percentage set for the loan.\n     * @param loanId The id of the loan to get the interest percentage from.\n     * @return totalInterest The total amount of interest to be paid to settle the loan.\n     */\n    function getTotalInterest(uint256 loanId)\n        public\n        view\n        returns (uint256 totalInterest)\n    {\n        // Substract the partitions already paid in project tokens from the lending amount to pay back\n        uint256 lendingTokenAmount =\n            loanDetails[loanId].lendingAmount.sub(\n                projectLoanPayments[loanId].partitionsPaidInProjectTokens.mul(\n                    baseAmountForEachPartition\n                )\n            );\n        // Calculate the interest only over what is left to pay in the lending token\n        totalInterest = lendingTokenAmount\n            .mul(loanDetails[loanId].interestPercentage)\n            .div(100);\n    }\n\n    function balanceOfAllFundingNFTGenerations(uint256 loanId, address funder)\n        public\n        view\n        returns (uint256 balance)\n    {\n        for (\n            uint256 i = 0;\n            i < projectLoanPayments[loanId].totalMilestones;\n            i++\n        ) {\n            balance = balance.add(\n                balanceOfFundingNFTGeneration(loanId, i, funder)\n            );\n        }\n    }\n\n    function balanceOfFundingNFTGeneration(\n        uint256 loanId,\n        uint256 generation,\n        address funder\n    ) public view returns (uint256 balance) {\n        balance = fundingNFT.balanceOf(funder, generation.getTokenId(loanId));\n    }\n\n    function getProjectTokenPrice(uint256 loanId)\n        public\n        view\n        returns (uint256 price)\n    {\n        // The price tokens can be reclaimed for after a milestone delivery\n        uint256 milestonePriceWasSet =\n            projectLoanPayments[loanId].milestonesDelivered > 0\n                ? projectLoanPayments[loanId].milestonesDelivered.sub(1)\n                : 0;\n        price = projectLoanPayments[loanId].milestoneProjectTokenPrice[\n            milestonePriceWasSet\n        ];\n    }\n\n    function getDiscountedProjectTokenPrice(uint256 loanId)\n        public\n        view\n        returns (uint256 price)\n    {\n        uint256 marketPrice = getProjectTokenPrice(loanId);\n        price = marketPrice.sub(\n            marketPrice.mul(projectLoanPayments[loanId].discountPerMillion).div(\n                10**6\n            )\n        );\n    }\n\n    function getAvailableFundingNFTForConversion(uint256 loanId, address funder)\n        public\n        view\n        returns (uint256 balance)\n    {\n        // If the loan is already settled, the seeker already paid everything back and also got its collateral back already\n        if (loanStatus[loanId] == LoanLibrary.LoanStatus.SETTLED) {\n            return 0;\n        }\n\n        for (\n            uint256 i = 0;\n            i < projectLoanPayments[loanId].milestonesDelivered;\n            i++\n        ) {\n            balance = balance.add(\n                balanceOfFundingNFTGeneration(loanId, i, funder)\n            );\n        }\n    }\n\n    function getAmountOfProjectTokensToReceive(\n        uint256 loanId,\n        uint256 amountFundingNFT\n    ) public view returns (uint256 amount) {\n        uint256 amountToReceiveInProjectTokens =\n            amountFundingNFT.mul(baseAmountForEachPartition);\n        // Calculate amount of project tokens based on the discounted price\n        amount = amountToReceiveInProjectTokens.div(\n            getDiscountedProjectTokenPrice(loanId)\n        );\n    }\n}\n"
    },
    "contracts/mocks/Tests/RegistryV2Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\nimport \"../../Registry.sol\";\n\n/**\n * @title AllianceBlock Registry contract\n * @notice Responsible for loan transactions.\n */\ncontract RegistryV2Test is Registry {\n    // Only for test upgrade\n    uint256 public foo;\n    uint256 public bar;\n\n    /**\n    * @dev Only for testing purposes\n    */\n    function getSomething1() public view returns (uint256) {\n        return 1;\n    }\n\n    /**\n    * @dev Only for testing purposes\n    */\n    function getSomething2() public view returns (uint256) {\n        return 2;\n    }\n}\n"
    },
    "contracts/NFTs/MainNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n/**\n * @title Alliance Block Main NFT\n * @notice NFT custodied Asset\n */\ncontract MainNFT is Initializable, ERC721Upgradeable  {\n\n    /**\n     * @dev Initializes the contract by setting the name, symbol, and base URI\n     */\n    function initialize(string memory name, string memory symbol) public initializer {\n        __ERC721_init(name, symbol);\n        _setBaseURI(\"\");\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}